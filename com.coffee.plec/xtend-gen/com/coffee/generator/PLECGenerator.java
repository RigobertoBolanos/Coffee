/**
 * generated by Xtext 2.12.0
 */
package com.coffee.generator;

import com.coffee.generator.DIMACS.DIMACSGenerator;
import com.coffee.generator.THLCL.THLCLCardinalityGenerator;
import com.coffee.generator.THLCL.THLCLGenerator;
import com.coffee.generator.TypeOfProblem;
import com.coffee.generator.XCSP3.XCSP3Generator;
import com.coffee.pLEC.ConsExpression;
import com.coffee.pLEC.Constraint;
import com.coffee.pLEC.Model;
import com.coffee.pLEC.Structural;
import com.coffee.pLEC.VarDeclaration;
import com.google.common.base.Objects;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class PLECGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    final String modelName = this.modelName(((Model) _head));
    EObject _head_1 = IterableExtensions.<EObject>head(resource.getContents());
    final Model model = ((Model) _head_1);
    final TypeOfProblem typeOfProblem = this.setTypeOfProblem(model);
    fsa.generateFile((modelName + ".hlcl"), this.toTHLCL(model, modelName, typeOfProblem));
    boolean _equals = Objects.equal(typeOfProblem, TypeOfProblem.SAT);
    if (_equals) {
      fsa.generateFile((modelName + ".cnf"), this.toDIMACS(model, modelName, typeOfProblem));
    } else {
      fsa.generateFile((modelName + ".xml"), this.toXCSP3(model, modelName, typeOfProblem));
    }
  }
  
  /**
   * Method to obtain the name of the model
   * @param modes is of type Model
   * @retuns String name with the name of the model
   */
  public String modelName(final Model model) {
    String name = StringExtensions.toFirstUpper(model.getName());
    return name;
  }
  
  /**
   * Method that determines the type of the problem regarding the types of the variables and
   * type of the constraints
   * @param model is an abstract representation of the model
   */
  public TypeOfProblem setTypeOfProblem(final Model model) {
    TypeOfProblem _typeOfVariables = this.typeOfVariables(model);
    boolean _equals = Objects.equal(_typeOfVariables, TypeOfProblem.CSP_INST);
    if (_equals) {
      return TypeOfProblem.CSP_INST;
    } else {
      if ((Objects.equal(this.typeOfVariables(model), TypeOfProblem.SAT) && 
        Objects.equal(this.typeOfConstraints(model), TypeOfProblem.SAT))) {
        return TypeOfProblem.SAT;
      } else {
        return TypeOfProblem.CSP;
      }
    }
  }
  
  /**
   * Method to obtain a Textual HLCL representation of the model
   * @param the model
   * @return a sequence of characters to create a .hlcl file
   */
  public CharSequence toTHLCL(final Model model, final String modelName, final TypeOfProblem typeOfProblem) {
    CharSequence _xblockexpression = null;
    {
      THLCLGenerator thlcl = new THLCLGenerator(modelName, typeOfProblem);
      if (typeOfProblem != null) {
        switch (typeOfProblem) {
          case CSP_INST:
            THLCLCardinalityGenerator _tHLCLCardinalityGenerator = new THLCLCardinalityGenerator(modelName, typeOfProblem);
            thlcl = _tHLCLCardinalityGenerator;
            break;
          default:
            THLCLGenerator _tHLCLGenerator = new THLCLGenerator(modelName, typeOfProblem);
            thlcl = _tHLCLGenerator;
            break;
        }
      } else {
        THLCLGenerator _tHLCLGenerator = new THLCLGenerator(modelName, typeOfProblem);
        thlcl = _tHLCLGenerator;
      }
      _xblockexpression = thlcl.parseModel(model);
    }
    return _xblockexpression;
  }
  
  /**
   * Method to obtain a XCSP3 representation of the model
   * @param the model
   * @return a sequence of characters to create a .xcsp3 file
   */
  public CharSequence toXCSP3(final Model model, final String modelName, final TypeOfProblem typeOfProblem) {
    CharSequence _xblockexpression = null;
    {
      XCSP3Generator xcsp3 = null;
      if (typeOfProblem != null) {
        switch (typeOfProblem) {
          case CSP_INST:
            XCSP3Generator _xCSP3Generator = new XCSP3Generator(modelName, typeOfProblem);
            xcsp3 = _xCSP3Generator;
            break;
          default:
            XCSP3Generator _xCSP3Generator_1 = new XCSP3Generator(modelName, typeOfProblem);
            xcsp3 = _xCSP3Generator_1;
            break;
        }
      } else {
        XCSP3Generator _xCSP3Generator_1 = new XCSP3Generator(modelName, typeOfProblem);
        xcsp3 = _xCSP3Generator_1;
      }
      _xblockexpression = xcsp3.parseModel(model);
    }
    return _xblockexpression;
  }
  
  /**
   * Method to obtain a Dimacs representation of the model
   * @param the model
   * @return a sequence of characters to create a textual file
   * with the sat problem in DIMACS format file
   */
  public CharSequence toDIMACS(final Model model, final String modelName, final TypeOfProblem typeOfProblem) {
    CharSequence _xblockexpression = null;
    {
      DIMACSGenerator dimacs = new DIMACSGenerator(modelName, typeOfProblem);
      _xblockexpression = dimacs.parseModel(model);
    }
    return _xblockexpression;
  }
  
  /**
   * Method to determine the type of the constraints
   * If there are one constraint that cannot be mapped into a boolean
   * constraint, then the method returns CSP.
   * @param model
   * @return TypeOfProblem (CSP, SAT)
   */
  public TypeOfProblem typeOfConstraints(final Model model) {
    EList<Constraint> _constraints = model.getConstraints();
    for (final Constraint cons : _constraints) {
      ConsExpression _exp = cons.getExp();
      if ((_exp instanceof Structural)) {
        ConsExpression _exp_1 = cons.getExp();
        final com.coffee.pLEC.Number min = ((Structural) _exp_1).getMin();
        ConsExpression _exp_2 = cons.getExp();
        final com.coffee.pLEC.Number max = ((Structural) _exp_2).getMax();
        if (((min != null) && (max != null))) {
          if (((!((min.getValue() == 0) && (max.getValue() >= 1))) && (!((min.getValue() == 1) && (max.getValue() == 1))))) {
            return TypeOfProblem.CSP;
          }
        }
      }
    }
    return TypeOfProblem.SAT;
  }
  
  /**
   * Method to determine the type of the variables
   * If there are one variable that cannot be mapped into a boolean
   * variable, then the method returns CSP.
   * @param model
   * @return TypeOfProblem (CSP, SAT, CSP_INST)
   */
  public TypeOfProblem typeOfVariables(final Model model) {
    boolean isInstanciable = false;
    boolean isInteger = false;
    EList<VarDeclaration> _vars = model.getVars();
    for (final VarDeclaration variable : _vars) {
      {
        if (((variable.getMin() != null) && (variable.getMax() != null))) {
          isInstanciable = true;
          return TypeOfProblem.CSP_INST;
        }
        String _type = variable.getType();
        boolean _equals = Objects.equal(_type, "integer");
        if (_equals) {
          isInteger = true;
        }
      }
    }
    if (isInteger) {
      return TypeOfProblem.CSP;
    } else {
      return TypeOfProblem.SAT;
    }
  }
}

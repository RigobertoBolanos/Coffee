package com.coffee.generator.THLCL;

import com.coffee.generator.AbstractGenerator;
import com.coffee.generator.CodeFactory;
import com.coffee.generator.THLCL.BooleanFactory;
import com.coffee.generator.THLCL.IntegerFactory;
import com.coffee.generator.THLCL.OptimizationFactory;
import com.coffee.generator.TypeOfProblem;
import com.coffee.pLEC.Attributes;
import com.coffee.pLEC.ConsExpression;
import com.coffee.pLEC.Expression;
import com.coffee.pLEC.Model;
import com.coffee.pLEC.Rule;
import com.coffee.pLEC.VarDeclaration;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;

/**
 * Code generator for parse from the PLEC language to the Textual High Level Constraint
 * Language (THLCL)
 * This class implements the Generator interface
 * @author Angela Villota
 * @version PLEC V3
 * August 2018
 */
@SuppressWarnings("all")
public class THLCLGenerator extends AbstractGenerator {
  /**
   * object to obtain the program sentences regarding the type of the problem
   */
  private CodeFactory factory;
  
  /**
   * Constructor method
   * @param the name of the model
   */
  public THLCLGenerator(final String name, final TypeOfProblem type) {
    super(name, type);
    TypeOfProblem _typeOfProblem = this.getTypeOfProblem();
    if (_typeOfProblem != null) {
      switch (_typeOfProblem) {
        case SAT:
          BooleanFactory _booleanFactory = new BooleanFactory();
          this.factory = _booleanFactory;
          break;
        case CSP:
          IntegerFactory _integerFactory = new IntegerFactory();
          this.factory = _integerFactory;
          break;
        case COP:
          OptimizationFactory _optimizationFactory = new OptimizationFactory();
          this.factory = _optimizationFactory;
          break;
        default:
          break;
      }
    }
    this.setFactory(this.factory);
  }
  
  /**
   * Method to obtain a sequence of characters containing the
   * constraint program in the Textual HLCL language
   * @param model is an ECORE syntax tree with the program
   * this syntax tree should be traversed.
   */
  @Override
  public CharSequence parseModel(final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _header = this.factory.getHeader();
    _builder.append(_header);
    _builder.append(" ");
    String _modelName = this.getModelName();
    _builder.append(_modelName);
    _builder.newLineIfNotEmpty();
    CharSequence _varLabel = this.factory.getVarLabel();
    _builder.append(_varLabel);
    _builder.newLineIfNotEmpty();
    CharSequence _putAutogeneratedVars = this.putAutogeneratedVars();
    _builder.append(_putAutogeneratedVars);
    _builder.newLineIfNotEmpty();
    CharSequence _parseVariables = this.parseVariables(model);
    _builder.append(_parseVariables);
    _builder.newLineIfNotEmpty();
    CharSequence _consLabel = this.factory.getConsLabel();
    _builder.append(_consLabel);
    _builder.newLineIfNotEmpty();
    CharSequence _putAutogeneratedCons = this.putAutogeneratedCons();
    _builder.append(_putAutogeneratedCons);
    _builder.newLineIfNotEmpty();
    CharSequence _parseConstraints = this.parseConstraints(model);
    _builder.append(_parseConstraints);
    _builder.newLineIfNotEmpty();
    CharSequence _strategy = this.factory.getStrategy();
    _builder.append(_strategy);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  @Override
  public CharSequence parseConstraint(final String id, final ConsExpression exp) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(id);
    _builder.append(": ");
    CharSequence _parseExpression = this.parseExpression(exp);
    _builder.append(_parseExpression);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  /**
   * @param rule is an expression of type rule
   */
  @Override
  public CharSequence parseRule(final Rule rule) {
    StringConcatenation _builder = new StringConcatenation();
    Expression _condition = rule.getCondition();
    final CharSequence left = this.parseExpression(((ConsExpression) _condition));
    _builder.newLineIfNotEmpty();
    Expression _consequence = rule.getConsequence();
    final CharSequence right = this.parseExpression(((ConsExpression) _consequence));
    _builder.newLineIfNotEmpty();
    _builder.append("(");
    _builder.append(left);
    _builder.append(") => (");
    _builder.append(right);
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  /**
   * Falta considerar el caso cuando hay más de un atributo,
   * es decir cuando la lista tiene más de un elemento
   */
  @Override
  public CharSequence parseAttributes(final Attributes exp) {
    StringConcatenation _builder = new StringConcatenation();
    final String left = exp.getVar1().getName();
    _builder.newLineIfNotEmpty();
    {
      EList<VarDeclaration> _ids = exp.getAtt().getIds();
      for(final VarDeclaration att : _ids) {
        _builder.append(left);
        _builder.append(" <=> (");
        String _name = att.getName();
        _builder.append(_name);
        _builder.append(" > 0)");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  @Override
  public CharSequence putAutogeneratedVars() {
    StringConcatenation _builder = new StringConcatenation();
    return _builder;
  }
  
  @Override
  public CharSequence putAutogeneratedCons() {
    StringConcatenation _builder = new StringConcatenation();
    String _clonConstraints = this.factory.getClonConstraints();
    _builder.append(_clonConstraints);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
}

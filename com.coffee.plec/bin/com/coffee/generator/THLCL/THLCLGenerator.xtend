package com.coffee.generator.THLCL

import com.coffee.pLEC.Model
import com.coffee.pLEC.ConsExpression
import com.coffee.pLEC.Rule
import com.coffee.pLEC.Attributes
import com.coffee.generator.TypeOfProblem

//data structure imports
import com.coffee.generator.AbstractGenerator
import com.coffee.pLEC.VarDeclaration

/**
 * Code generator for parse from the PLEC language to the Textual High Level Constraint
 * Language (THLCL)
 * This class implements the Generator interface
 * @author Angela Villota
 * @version PLEC V3
 * August 2018
 */

class THLCLGenerator extends AbstractGenerator{
	/**
	 * object to obtain the program sentences regarding the type of the problem
	 */
	private THLCLFactory factory;
	
	
	/**
	 * Constructor method 
	 * @param name the name of the model
	 * @param type is the TypeOfProblem (SAT, CSP)
	 */
	new(String name, TypeOfProblem type) {
		super(name, type)
		switch typeOfProblem{
			 case SAT: factory= new BooleanFactory()
			 case CSP: factory= new IntegerFactory()
			 case COP: factory= new OptimizationFactory()
			 case CSP_INST: factory= new IntegerFactory()
		}
		setFactory(factory)
	}

	/**
	 * Method to produce a sequence of characters with the 
	 * model represented as a constraint problem using  the 
	 * Textual HLCL language (model.hlcl)
	 * @param model is an ECORE syntax tree with the program
	 * this syntax tree should be traversed. 
	 */
	override parseModel(Model model) {
		
		switch typeOfProblem{
			case SAT:
			'''
			 «factory.getHeader» «modelName»
			 «factory.getVarLabel»
			 «parseVariables(model)»
			 «factory.getConsLabel»
			 «parseConstraints(model)»
			 '''
			 case CSP:
			 '''
			 «factory.getHeader» «modelName»
			 «factory.getVarLabel»
			 «parseVariables(model)»
			 «factory.getConsLabel»
			 «putAutogeneratedCons()»
			 «parseConstraints(model)»
			 '''
			 case COP:
			 '''
			 «factory.getHeader» «modelName»
			 «factory.getVarLabel»
			 «parseVariables(model)»
			 «factory.getConsLabel»
			 «putAutogeneratedCons()»
			 «parseConstraints(model)»
			 «factory.getStrategy()»
			 '''
//			 case CSP_INST:
//			 '''
//			 Instances code
//			 '''
		}
	}
	
	/**
	 * Returns the code associated to a constraint of type Rule
	 * This method first translates the constraints, then call a 
	 * factory for calling the rule
	 * @param rule is an expression of Type Rule
	 */
	override parseRule(Rule rule) {
		
		val left= parseExpression(rule.condition as ConsExpression)
		val right= parseExpression (rule.consequence as ConsExpression)
		factory.getRule(left, right)
		
	}
	
	/**
	 * 
	 */
	override parseAttributes(Attributes exp) {
		factory.getAttributes(exp)
	}
	
	/**
	 * Returns the generated code for a particular constraint in the Textual
	 * HLCL format
	 * @param id is a String containing the identifier of the constraint
	 * @param exp is a ConsExpression (to be parsed)
	 */	
	override parseConstraint(String id, ConsExpression exp){
		'''
		«id»: «parseExpression(exp)»
		'''	
	}

	/**
	 * Returns the generated code for the constraints autogenerated giving clonning
	 * and cardinality relations 
	 */
	override putAutogeneratedCons() {
		factory.getClonConstraints()
	}
	
}
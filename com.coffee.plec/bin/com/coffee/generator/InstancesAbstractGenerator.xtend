package com.coffee.generator

import com.coffee.pLEC.Model
import com.coffee.pLEC.ConsExpression
import com.coffee.pLEC.Rule
import com.coffee.pLEC.Structural
import com.coffee.pLEC.FodaBin
import com.coffee.pLEC.FodaUN
import com.coffee.pLEC.Attributes
import com.coffee.pLEC.VarDeclaration
import java.util.HashMap
import java.util.Map
import com.coffee.pLEC.IDCons
import com.coffee.generator.variabilityTree.Node

/**
 * Generic Generator, this is the class that process the model and traverses the 
 * syntax tree creating a special data-structure for supporting complex cardinalities
 * @author Angela Villota
 * @version PLEC V3
 * Septembre 2018
 */
 abstract class InstancesAbstractGenerator extends AbstractGenerator{
	/**
	 * Name of the PL model 
	 */
	private String modelName
	
	/**
	 * Name of the root variable
	 */
	private String root
	
	/**
	 * String for including the declaration of the variables
	 */
	private StringBuilder variablesDeclarations;
	
	/**
	 * 
	 */
	 private Map<String, Node> tree
	
	/**
	 * type of problem is
	 * - CSP_INST, for supporting complex cardinalities
	 */
	private TypeOfProblem typeOfProblem
	/**
	 * object to obtain the program sentences regarding the type of the problem
	 */
	private CodeFactory factory;
	
	/**
	 * Map with the parent of each variable, for structural relations
	 */
	private Map <String, VarDeclaration> parents; // aquí debe quedar el nodo inicial
	
	/**
	 * Constructor method 
	 * @param the name of the model
	 * @param type of the problem
	 */
	new(String name, TypeOfProblem type) {
		super(name, type)
		modelName= name
		typeOfProblem= type
		//initializing the data sctucture with the map of parents
		parents= new HashMap<String,VarDeclaration>();
		variablesDeclarations= new StringBuilder();
		tree= new HashMap<String, Node>();
	}

	
	/*===================================================================
	 *===================================================================
	  Methods that should be implemented in an instance of the generator (THLCLGenerator, XCSPGenerator)
	  */
	
	/**
	 * Method to obtain a sequence of characters containing the constraint
	 * representation of the model regarding the type of the problem and the
	 * notation.
	 * @param model is an ECORE syntax tree with the program
	 * this syntax tree should be traversed. 
	 */
	 abstract override parseModel(Model model) ;
	
	/**
	 * Returns the code associated to a constraint of type Rule
	 * @param rule is an expression of Type Rule
	 */
	abstract override CharSequence parseRule(Rule rule) ;
	
	/**
	 * For each attribute in the expression exp a constraint of the
	 * type element <=> («attribute» > 0) is generated
	 * @param exp is an expression of Type Attributes
	 */
	abstract override CharSequence parseAttributes(Attributes exp) ;
	
	
	/**
	 * Returns the generated code for a particular constraint
	 * @param id is a String containing the identifier of the constraint
	 * @param exp is a ConsExpression (to be parsed)
	 */
	abstract override CharSequence parseConstraint(String id, ConsExpression exp);
	
	/**
	 * Returns the generated code for the constraints autogenerated giving clonning
	 * and cardinality relations 
	 */
	//abstract override putAutogeneratedCons() ;

	
	/*===================================================================
	 *===================================================================
	 * Implemented Methods 
	 */
		
	/**
	 * This method traverses the list of variables to parse each declaration
	 * The declaration is made by the factory 
	 * @param model
	 */
	override parseVariables(Model model) {
		
		for( variable : model.vars){
			val Node node = new Node(variable.name)
			node.setMin(variable.min.value)
			node.setMax(variable.max.value)
			tree.put(variable.name, node)
		}
		''''''
	}
	/**
	 * Method to parse the constraints in a model.
	 * The constraints are contained in a collection 
	 * of constraints
	 * @param model 
	 */	
	override parseConstraints(Model model) {
		for(c: model.constraints){
			if (c.exp instanceof Structural){
				val exp= c.exp as Structural
				val padre= tree.get(exp.parent)
				for (childVar : exp.group.ids) {
					val childNode= tree.get(childVar.name)
					childNode.setParent(padre)
					childNode.numInstances = padre.numInstances * childVar.max.value
					padre.addChild(childNode)
					for (nameV: padre.varsIds){
						for (var i=1; i<= childNode.max; i++){
							childNode.addVarId('''«nameV»_«childVar.name»_«i»''')
						}
					}
				}
				if (exp.min!==null && exp.max!==null){
					parseConstraint( c.name, c.exp)
				}
			}else{	
				if(c.exp instanceof Attributes){
					val exp= c.exp as Attributes
					val padre= tree.get(exp.var1)
					for (att : exp.att.ids) {
					val childNode= tree.get(att.name)
					childNode.setParent(padre)
					childNode.numInstances = padre.numInstances * 1 // an attribute has one cardinality
					padre.addChild(childNode)
					for (nameV: padre.varsIds){
						for (var i=1; i<= childNode.max; i++){
							childNode.addVarId('''«nameV»_«att.name»_«i»''')
						}
					}
				}
					//hacer lo que se hizo arriba pero tener en cuenta que un att no tiene hijos
				}
				else{
					
				}
			}
		}
//		«FOR c : model.constraints»
//			«IF c.exp instanceof Structural »
//				«var exp= c.exp as Structural»
//				«IF exp.min===null && exp.max===null »
//					«parseStructuralNoCard( exp)»
//				«ELSE»
//				«parseConstraint( c.name, c.exp)»
//				«ENDIF»
//			«ELSE»
//				«parseConstraint( c.name, c.exp)»
//			«ENDIF»	
//		«ENDFOR»
	''''''
	}
	

	
	/**
	 * This method is used to determine he type of an expression and
	 * call the method in charge to produce the code.
	 * @param exp is a constraint expression
	 */
	override parseExpression(ConsExpression exp) {
		'''
		«IF exp instanceof IDCons»
			«exp.name»
		«ELSE»
			«IF exp instanceof FodaBin»
				«parseFodaBinary(exp)»
			«ELSE»
				«IF exp instanceof Rule»
					«parseRule(exp)»
				«ELSE»
					«IF exp instanceof Structural»
						«parseStructuralCard(exp)»
					«ELSE»
						«IF exp instanceof FodaUN»
							«parseFodaUnary(exp)»
						«ELSE»
							«IF exp instanceof Attributes»
								«parseAttributes(exp)»
							«ENDIF»
						«ENDIF»
					«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
		'''
	}

	/**
	 * This method does not generate code, just keeps track 
	 * the parents of each element in an structural relation 
	 * @param exp is a Structural relation
	 */
	override parseStructuralNoCard(Structural exp) {
		addParents(exp)
		''''''
	}
	
	/**
	 * Method obtaining the representation of an structural expression
	 * this method calls the factory because the code is dependent of the type of
	 * problem and the type of file
	 * @param exp is an structural expression 
	 */
	override parseStructuralCard(Structural exp) {
		factory.getGroupCardinality(exp, parents)
	}
	
	/**
	 * Method obtaining the representation of FODA expression 
	 * this method calls the factory because the code is dependent of the type of
	 * problem and the type of file
	 * @param exp is Foda expression with two variables
	 */
	override parseFodaBinary(FodaBin exp) {
		'''
		«IF exp.op=="requires"»
			«factory.getRequires(exp.var1, exp.var2)»
		«ELSE»
			«IF exp.op=="excludes"»
				«factory.getExcludes(exp.var1, exp.var2)»
			«ELSE»
				«IF exp.op=="mandatory"»
					«factory.getMandatory(exp.var1, exp.var2)»
				«ELSE»
					«factory.getOptional(exp.var1, exp.var2)»
				«ENDIF»
			«ENDIF»
		«ENDIF»
		'''
	}
	
	/**
	 * Method for parsing FODA operations with just one variable
	 * this is allowed because there exists a structural expression defined before
	 * @param exp is an unary FODA expression
	 */
	override parseFodaUnary(FodaUN exp) {
		'''
		«IF exp.op=="optional"»
			«factory.getOptional(parents.get(exp.var1.name),exp.var1)»
		«ELSE»
			«IF exp.op=="mandatory"»
				«factory.getMandatory(parents.get(exp.var1.name),exp.var1)»
			«ELSE»
			«ENDIF»
		«ENDIF»
		'''
	}
	
	/*===================================================================
	 *===================================================================
	 *  Getters and setters
	 */	
	override getModelName() {
		return modelName
	}
	
	override getTypeOfProblem() {
		return typeOfProblem
	}
	
	override addParents(Structural exp) {
		for (element : exp.group.ids) {
			parents.put(element.name, exp.parent)
		}
	}
	
	override getParents(){
		return parents
		
	}
	override void setFactory( CodeFactory factory){
		this.factory= factory
	}
	
	
}
package com.coffee.generator

import com.coffee.pLEC.Model
import com.coffee.pLEC.ConsExpression
import com.coffee.pLEC.Rule
import com.coffee.pLEC.Structural
import com.coffee.pLEC.FodaBin
import com.coffee.pLEC.FodaUN
import com.coffee.pLEC.Attributes
import com.coffee.pLEC.VarDeclaration
import java.util.HashMap
import java.util.Map
import com.coffee.pLEC.IDCons
import com.coffee.pLEC.Refinement
import com.coffee.pLEC.RootRefinement
import com.coffee.pLEC.SetRefinement
import com.coffee.pLEC.VarRefinement
import com.coffee.pLEC.Assignment
import com.coffee.pLEC.Quantifiable

/**
 * Generic Generator, this is the class that process the model and traverses the 
 * syntax tree regardless the type of notation and problem
 * @author Angela Villota
 * @version PLEC V3
 * August 2018
 */
 abstract class AbstractGenerator implements Generator{
	/**
	 * Name of the PL model 
	 */
	private String modelName
	
	/**
	 * type of problem can be 
	 * - SAT, for boolean variables and constraints 
	 * - CSP, for mixed boolean and integer variables and constraints
	 * - COP, for an optimization constraint problem
	 */
	private TypeOfProblem typeOfProblem
	/**
	 * object to obtain the program sentences regarding the type of the problem
	 */
	private CodeFactory factory;
	
	/**
	 * Map with the parent of each variable, for structural relations
	 */
	private Map <String, VarDeclaration> parents;
	
	/**
	 * Constructor method 
	 * @param the name of the model
	 * @param type of the problem
	 */
	new(String name, TypeOfProblem type) {
		modelName= name
		typeOfProblem= type
		//initializing the data sctucture with the map of parents
		parents= new HashMap<String,VarDeclaration>();
	}

	
	/*===================================================================
	 *===================================================================
	  Methods that should be implemented in an instance of the generator (THLCLGenerator, XCSPGenerator)
	  */
	
	/**
	 * Method to obtain a sequence of characters containing the constraint
	 * representation of the model regarding the type of the problem and the
	 * notation.
	 * @param model is an ECORE syntax tree with the program
	 * this syntax tree should be traversed. 
	 */
	 abstract override parseModel(Model model) ;
	
	/**
	 * Returns the code associated to a constraint of type Rule
	 * @param rule is an expression of Type Rule
	 */
	abstract override CharSequence parseRule(Rule rule) ;
	
	/**
	 * For each attribute in the expression exp a constraint of the
	 * type element <=> («attribute» > 0) is generated
	 * @param exp is an expression of Type Attributes
	 */
	abstract override CharSequence parseAttributes(Attributes exp) ;
	
	
	/**
	 * Returns the generated code for a particular constraint
	 * @param id is a String containing the identifier of the constraint
	 * @param exp is a ConsExpression (to be parsed)
	 */
	abstract override CharSequence parseConstraint(String id, ConsExpression exp);
	
	/**
	 * Returns the generated code for the constraints autogenerated giving clonning
	 * and cardinality relations 
	 */
	//abstract override putAutogeneratedCons() ;

	
	/*===================================================================
	 *===================================================================
	 * Implemented Methods 
	 */
		
	/**
	 * This method traverses the list of variables to parse each declaration
	 * The declaration is made by the factory 
	 * @param model
	 */
	override parseVariables(Model model) {
		'''
		«FOR variable : model.vars»
			«factory.getVariable(variable)»
		«ENDFOR»
		'''
	}
	/**
	 * Method to parse the constraints in a model.
	 * The constraints are contained in a collection 
	 * of constraints
	 * @param model 
	 */	
	override parseConstraints(Model model) {
		'''
		«FOR c : model.constraints»
			«IF c.exp instanceof Structural »
				«var exp= c.exp as Structural»
				«IF exp.min===null && exp.max===null »
					«parseStructuralNoCard( exp)»
				«ELSE»
				«parseConstraint( c.name, c.exp)»
				«ENDIF»
			«ELSE»
				«parseConstraint( c.name, c.exp)»
			«ENDIF»	
		«ENDFOR»
		'''
	}
	

	
	/**
	 * This method is used to determine he type of an expression and
	 * call the method in charge to produce the code.
	 * @param exp is a constraint expression
	 */
	override parseExpression(ConsExpression exp) {
		'''
		«IF exp instanceof IDCons»
			«exp.name»
		«ELSE»
			«IF exp instanceof FodaBin»
				«parseFodaBinary(exp)»
			«ELSE»
				«IF exp instanceof Rule»
					«parseRule(exp)»
				«ELSE»
					«IF exp instanceof Structural»
						«parseStructuralCard(exp)»
					«ELSE»
						«IF exp instanceof FodaUN»
							«parseFodaUnary(exp)»
						«ELSE»
							«IF exp instanceof Attributes»
								«parseAttributes(exp)»
							«ELSE»
								«IF exp instanceof Refinement»
									«parseRefinement(exp)»
								«ELSE»
									«IF exp instanceof Quantifiable»
										«parseQuantifiable(exp)»
									«ENDIF»
								«ENDIF»
							«ENDIF»
						«ENDIF»
					«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
		'''
	}
	
	/**
	 * 
	 */
	 override  CharSequence parseQuantifiable(Quantifiable exp);
	
	
	/**
	 * 
	 */
	 override  CharSequence parseRefinement(Refinement exp){
	 	if (exp instanceof RootRefinement){
	 		factory.getRootConstraint(exp)
	 	}
	 	else{
	 		if(exp instanceof SetRefinement){
	 			
	 		}
	 		else{
	 			if(exp instanceof VarRefinement){
	 				
	 			}else{
	 				if(exp instanceof Assignment){
	 					factory.getAssignement(exp)
	 				}
	 			}
	 		}
	 	}
	 }

	/**
	 * This method does not generate code, just keeps track 
	 * the parents of each element in an structural relation 
	 * @param exp is a Structural relation
	 */
	override parseStructuralNoCard(Structural exp) {
		addParents(exp)
		''''''
	}
	
	/**
	 * Method obtaining the representation of an structural expression
	 * this method calls the factory because the code is dependent of the type of
	 * problem and the type of file
	 * @param exp is an structural expression 
	 */
	override parseStructuralCard(Structural exp) {
		factory.getGroupCardinality(exp, parents)
	}
	
	/**
	 * Method obtaining the representation of FODA expression 
	 * this method calls the factory because the code is dependent of the type of
	 * problem and the type of file
	 * @param exp is Foda expression with two variables
	 */
	override parseFodaBinary(FodaBin exp) {
		'''
		«IF exp.op=="requires"»
			«factory.getRequires(exp.var1, exp.var2)»
		«ELSE»
			«IF exp.op=="excludes"»
				«factory.getExcludes(exp.var1, exp.var2)»
			«ELSE»
				«IF exp.op=="mandatory"»
					«factory.getMandatory(exp.var1, exp.var2)»
				«ELSE»
					«factory.getOptional(exp.var1, exp.var2)»
				«ENDIF»
			«ENDIF»
		«ENDIF»
		'''
	}
	
	/**
	 * Method for parsing FODA operations with just one variable
	 * this is allowed because there exists a structural expression defined before
	 * @param exp is an unary FODA expression
	 */
	override parseFodaUnary(FodaUN exp) {
		'''
		«IF exp.op=="optional"»
			«factory.getOptional(parents.get(exp.var1.name),exp.var1)»
		«ELSE»
			«IF exp.op=="mandatory"»
				«factory.getMandatory(parents.get(exp.var1.name),exp.var1)»
			«ELSE»
			«ENDIF»
		«ENDIF»
		'''
	}
	
	/*===================================================================
	 *===================================================================
	 *  Getters and setters
	 */	
	override getModelName() {
		return modelName
	}
	
	override getTypeOfProblem() {
		return typeOfProblem
	}
	
	override addParents(Structural exp) {
		for (element : exp.group.ids) {
			parents.put(element.name, exp.parent)
		}
	}
	
	override getParents(){
		return parents
		
	}
	override void setFactory( CodeFactory factory){
		this.factory= factory
	}
	
	
}
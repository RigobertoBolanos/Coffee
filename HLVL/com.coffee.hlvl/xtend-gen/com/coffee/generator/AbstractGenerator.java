package com.coffee.generator;

import com.coffee.generator.Dialect;
import com.coffee.generator.IGenerator;
import com.coffee.generator.TransformationRules;
import com.coffee.hlvl.ComplexImplies;
import com.coffee.hlvl.ConstantDecl;
import com.coffee.hlvl.Core;
import com.coffee.hlvl.Declaration;
import com.coffee.hlvl.Decomposition;
import com.coffee.hlvl.ElmDeclaration;
import com.coffee.hlvl.Expression;
import com.coffee.hlvl.Group;
import com.coffee.hlvl.Model;
import com.coffee.hlvl.MultInstantiation;
import com.coffee.hlvl.Pair;
import com.coffee.hlvl.QImplies;
import com.coffee.hlvl.RelDeclaration;
import com.coffee.hlvl.Relation;
import com.coffee.hlvl.Value;
import com.coffee.hlvl.VarList;
import com.coffee.hlvl.VariableDecl;
import com.coffee.hlvl.Visibility;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;

/**
 * Abstract Generator, this is the class that process the model and traverses the
 * syntax tree regardless the type of notation and problem
 * @author Angela Villota
 * @version HLVL 1
 * August 2018
 * adpated to the HLVl grammar on January 2019
 */
@SuppressWarnings("all")
public abstract class AbstractGenerator implements IGenerator {
  /**
   * Name of the PL model
   */
  private String modelName;
  
  private Dialect dialect;
  
  /**
   * object to obtain the program sentences regarding the type of the problem
   */
  private TransformationRules rules;
  
  /**
   * Map with the parent of each variable, for decomposition relations
   */
  private Map<String, ElmDeclaration> parents;
  
  /**
   * Map with the parent of each variable, for decomposition relations
   */
  private Map<String, Relation> relations;
  
  private Map<String, ElmDeclaration> attributes;
  
  private StringBuilder operations;
  
  /**
   * Constructor method
   * @param the name of the model
   * @param type of the problem
   */
  public AbstractGenerator(final String name, final Dialect dialect) {
    this.modelName = name;
    this.dialect = dialect;
    HashMap<String, ElmDeclaration> _hashMap = new HashMap<String, ElmDeclaration>();
    this.parents = _hashMap;
    HashMap<String, ElmDeclaration> _hashMap_1 = new HashMap<String, ElmDeclaration>();
    this.attributes = _hashMap_1;
    HashMap<String, Relation> _hashMap_2 = new HashMap<String, Relation>();
    this.relations = _hashMap_2;
    StringBuilder _stringBuilder = new StringBuilder();
    this.operations = _stringBuilder;
  }
  
  /**
   * Method to obtain a sequence of characters containing the constraint
   * representation of the model regarding the type of the problem and the
   * notation.
   * @param model is an ECORE syntax tree with the program
   * this syntax tree should be traversed.
   */
  @Override
  public CharSequence parseModel(final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("% Autogenerated code form the Coffee framework");
    _builder.newLine();
    _builder.append("% Author: avillota");
    _builder.newLine();
    _builder.append("% Variables from elements definitions ");
    _builder.newLine();
    CharSequence _parseElements = this.parseElements(model);
    _builder.append(_parseElements);
    _builder.newLineIfNotEmpty();
    _builder.append("% Variables and constraints from the variability relations definition");
    _builder.newLine();
    CharSequence _parseRelations = this.parseRelations(model);
    _builder.append(_parseRelations);
    _builder.newLineIfNotEmpty();
    _builder.append("% The solving parameters from the parameters files");
    _builder.newLine();
    CharSequence _parseOperations = this.parseOperations(model);
    _builder.append(_parseOperations);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  /**
   * This method traverses the list of variables to parse each declaration
   * The declaration is made by the factory
   * @param model
   */
  @Override
  public CharSequence parseElements(final Model model) {
    String _xblockexpression = null;
    {
      String out = "";
      EList<ElmDeclaration> _elements = model.getElements();
      for (final ElmDeclaration element : _elements) {
        if (((element.getAtt() != null) && Objects.equal(element.getAtt(), "att"))) {
          this.attributes.put(element.getName(), element);
        } else {
          Declaration _declaration = element.getDeclaration();
          if ((_declaration instanceof ConstantDecl)) {
            Declaration _declaration_1 = element.getDeclaration();
            final Value value = ((ConstantDecl) _declaration_1).getValue();
            if ((Objects.equal(element.getDataType(), "boolean") && (value == null))) {
              String _out = out;
              CharSequence _element = this.rules.getElement(element);
              out = (_out + _element);
            } else {
              String _out_1 = out;
              CharSequence _constant = this.rules.getConstant(element);
              out = (_out_1 + _constant);
            }
          } else {
            Declaration _declaration_2 = element.getDeclaration();
            if ((_declaration_2 instanceof VariableDecl)) {
              String _out_2 = out;
              CharSequence _element_1 = this.rules.getElement(element);
              out = (_out_2 + _element_1);
            }
          }
        }
      }
      _xblockexpression = out;
    }
    return _xblockexpression;
  }
  
  /**
   * Method to parse the constraints in a model.
   * The constraints are contained in a collection
   * of constraints
   * @param model
   */
  @Override
  public CharSequence parseRelations(final Model model) {
    String _xblockexpression = null;
    {
      String out = "";
      EList<RelDeclaration> _relations = model.getRelations();
      for (final RelDeclaration e : _relations) {
        {
          this.relations.put(e.getName(), e.getExp());
          String _out = out;
          CharSequence _parseRelation = this.parseRelation(e.getExp());
          out = (_out + _parseRelation);
        }
      }
      _xblockexpression = out;
    }
    return _xblockexpression;
  }
  
  /**
   * This method is used to determine he type of an expression and
   * call the method in charge to produce the code.
   * @param exp is a constraint expression
   */
  @Override
  public CharSequence parseRelation(final Relation rel) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (rel instanceof Core) {
      _matched=true;
      _switchResult = this.rules.getCore(((Core)rel));
    }
    if (!_matched) {
      if (rel instanceof Decomposition) {
        _matched=true;
        _switchResult = this.rules.getDecomposition(((Decomposition)rel), this.parents);
      }
    }
    if (!_matched) {
      if (rel instanceof Group) {
        _matched=true;
        _switchResult = this.rules.getGroup(((Group)rel), this.parents);
      }
    }
    if (!_matched) {
      if (rel instanceof Pair) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          final Pair pair = ((Pair) rel);
          CharSequence _xifexpression = null;
          String _operator = pair.getOperator();
          boolean _equals = Objects.equal(_operator, "implies");
          if (_equals) {
            _xifexpression = this.rules.getImpliesPair(((Pair)rel).getVar1(), ((Pair)rel).getVar2());
          } else {
            _xifexpression = this.rules.getMutexPair(((Pair)rel).getVar1(), ((Pair)rel).getVar2());
          }
          _xblockexpression = _xifexpression;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof VarList) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          final VarList pair = ((VarList) rel);
          CharSequence _xifexpression = null;
          String _operator = pair.getOperator();
          boolean _equals = Objects.equal(_operator, "implies");
          if (_equals) {
            _xifexpression = this.rules.getImpliesList(((VarList)rel));
          } else {
            _xifexpression = this.rules.getMutexList(((VarList)rel));
          }
          _xblockexpression = _xifexpression;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof Expression) {
        _matched=true;
        _switchResult = this.rules.getExpression(((Expression)rel).getExp());
      }
    }
    if (!_matched) {
      if (rel instanceof Visibility) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          ArrayList<CharSequence> relations = new ArrayList<CharSequence>();
          EList<RelDeclaration> _ids = ((Visibility)rel).getChildren().getIds();
          for (final RelDeclaration r : _ids) {
            relations.add(this.parseRelation(r.getExp()));
          }
          _xblockexpression = this.rules.getVisibility(((Visibility)rel), relations);
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof MultInstantiation) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (rel instanceof QImplies) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (rel instanceof ComplexImplies) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    return _switchResult;
  }
  
  public CharSequence parseOperations(final Model model) {
    CharSequence _xblockexpression = null;
    {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("{");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("\"problemType\" : \"");
      String _string = this.dialect.toString();
      _builder.append(_string, " ");
      _builder.append("\",");
      _builder.newLineIfNotEmpty();
      this.operations.append(_builder);
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(" ");
      _xblockexpression = _builder_1;
    }
    return _xblockexpression;
  }
  
  /**
   * ===================================================================
   * ===================================================================
   *  Getters and setters
   */
  @Override
  public String getModelName() {
    return this.modelName;
  }
  
  @Override
  public Dialect getDialect() {
    return this.dialect;
  }
  
  @Override
  public void addParents(final Decomposition exp) {
    EList<ElmDeclaration> _values = exp.getChildren().getValues();
    for (final ElmDeclaration element : _values) {
      this.parents.put(element.getName(), exp.getParent());
    }
  }
  
  @Override
  public Map<String, ElmDeclaration> getParents() {
    return this.parents;
  }
  
  @Override
  public void setFactory(final TransformationRules factory) {
    this.rules = factory;
  }
  
  @Override
  public String getOperations(final long time) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(" ");
    _builder.append("\"parsingTime\"  : \"");
    _builder.append(time, " ");
    _builder.append("ms\"");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("}");
    this.operations.append(_builder);
    return this.operations.toString();
  }
}

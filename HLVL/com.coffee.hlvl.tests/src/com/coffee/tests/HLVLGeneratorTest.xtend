/*
 * generated by Xtext 2.12.0
 */
package com.coffee.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import com.coffee.hlvl.Model
import com.coffee.hlvl.HlvlPackage
import com.coffee.generator.ParserFactory
import com.coffee.generator.Dialect
import com.coffee.generator.HlvlGenerator

/**
 * Class to test the correct parsing of HLVL
 * @author Angela Villota
 * @version HLVL V4
 * November 2018
 * 
 */
@RunWith(XtextRunner)
@InjectWith(HlvlInjectorProvider)
class HLVLGeneratorTest {
	@Inject
	ParseHelper<Model> parseHelper
	
	@Test
	def void getDialect() {
		val basicProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		relations:
		r1: common(A,B)
		'''

		//This verifies that the models is syntactically correct
		var model = parseHelper.parse(basicProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		var HlvlGenerator gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.BASIC_BOOL, gen.findDialect(model))
		
		val attProgram = 
		'''
		model empty
		elements:
		boolean A
		att boolean B
		relations:
		r1: common(A,B)
		'''

		//This verifies that the models is syntactically correct
		 model = parseHelper.parse(attProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.ATTRIBUTE, gen.findDialect(model))
		
		val multProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		relations:
		r1: decomposition(A, [B], [1,4])
		'''

		//This verifies that the models is syntactically correct
		 model = parseHelper.parse(multProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.MULTIPLICITY, gen.findDialect(model))
		
		val attMultProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		att integer C variants: 1..5
		relations:
		r1: decomposition(A, [B], [1,4])
		'''

		//This verifies that the models is syntactically correct
		 model = parseHelper.parse(attMultProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		gen = new HlvlGenerator
		gen.findDialect(model)
		
		Assert.assertEquals(Dialect.MULTIPLICITY, gen.findDialect(model))
	}
	
	@Test
	def void boolParser() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model empty
		elements:
		boolean A
		boolean B
		relations:
		r1: common(A,B)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		var bool : A ;
		var bool : B ;
		% Variables and constraints from the variability relations definition
		constraint A == true ;
		constraint B == true ;
		% The solving parameters from the parameters files
		'''
		//Obtained code
		val parser= ParserFactory.getParser(Dialect.BASIC_BOOL, model.name);
		val actual= parser.parseModel(model)
		
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}
	
	@Test
	def void gplTest() {
		val hlvlProgram = 
		'''
		model GPL
		elements:  
			boolean GPL 
			boolean Gtp 
			boolean directed
			boolean undirected
			boolean Weight
			boolean weighted
			boolean unweighted
			boolean Search
			boolean BFS
			boolean DFS
			boolean Algorithms
			boolean connected
			boolean stronglyc
			boolean cycle
			boolean mstprim
			boolean mstkruskal
			boolean shortest
		relations:
			R1: common(GPL)
			R2: decomposition(GPL,[Weight, Search], [0,1])
			R3: decomposition(GPL, [Gtp, Algorithms], [1,1])
			R3X: group(Gtp, [directed, undirected], [1,1])
			R4: group(Weight, [weighted, unweighted], [1,1])
			R5: group(Search, [BFS, DFS], [1,1])
			R6: group(Algorithms, [connected, stronglyc, cycle, mstprim, mstkruskal, shortest], [1,*])
			R7: implies(mstprim, unweighted)
			R8: mutex(stronglyc, shortest)
			R9: expression(undirected OR ~mstprim)
			R10: expression(directed OR ~shortest)
			R11: expression( ~mstprim OR ~mstkruskal )
		 	R12: expression( unweighted OR ~mstkruskal )
		 	R13: expression( undirected OR ~stronglyc )
		 	R14: expression( ~connected OR ~stronglyc )
		 	R15: expression( Search OR ~connected )
		 	R16: expression( undirected OR ~mstkruskal )
		 	R17: expression( ~mstkruskal OR ~shortest )
		 	R18: expression( DFS OR ~cycle )
		 	R19: expression( ~mstprim OR ~shortest)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		//testing the generator
		val HlvlGenerator gen = new HlvlGenerator
		
		val parser= ParserFactory.getParser(gen.findDialect(model), model.name);
		
		val actual= parser.parseModel(model)
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		var bool : GPL ;
		var bool : Gtp ;
		var bool : directed ;
		var bool : undirected ;
		var bool : Weight ;
		var bool : weighted ;
		var bool : unweighted ;
		var bool : Search ;
		var bool : BFS ;
		var bool : DFS ;
		var bool : Algorithms ;
		var bool : connected ;
		var bool : stronglyc ;
		var bool : cycle ;
		var bool : mstprim ;
		var bool : mstkruskal ;
		var bool : shortest ;
		% Variables and constraints from the variability relations definition
		constraint GPL == true ;
		constraint Weight -> GPL ;
		constraint Search -> GPL ;
		constraint GPL <-> Gtp ;
		constraint GPL <-> Algorithms ;
		constraint directed <-> (not(undirected) /\ Gtp) ;
		constraint undirected <-> (not(directed) /\ Gtp) ;
		constraint weighted <-> (not(unweighted) /\ Weight) ;
		constraint unweighted <-> (not(weighted) /\ Weight) ;
		constraint BFS <-> (not(DFS) /\ Search) ;
		constraint DFS <-> (not(BFS) /\ Search) ;
		constraint Algorithms <-> ( connected \/ stronglyc \/ cycle \/ mstprim \/ mstkruskal \/ shortest ) ;
		constraint mstprim -> unweighted ;
		constraint not (stronglyc /\ shortest);
		constraint (undirected \/ not(mstprim)) ;
		constraint (directed \/ not(shortest)) ;
		constraint (not(mstprim) \/ not(mstkruskal)) ;
		constraint (unweighted \/ not(mstkruskal)) ;
		constraint (undirected \/ not(stronglyc)) ;
		constraint (not(connected) \/ not(stronglyc)) ;
		constraint (Search \/ not(connected)) ;
		constraint (undirected \/ not(mstkruskal)) ;
		constraint (not(mstkruskal) \/ not(shortest)) ;
		constraint (DFS \/ not(cycle)) ;
		constraint (not(mstprim) \/ not(shortest)) ;
		% The solving parameters from the parameters files
		'''
		//Obtained code

		
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}

	
	@Test
	def void basicIntegerParser() {
		// An empty hlvl program
		val hlvlProgram = 
		'''
		model GPL
		elements:  
			boolean GPL 
			boolean Gtp 
			boolean directed
			boolean undirected
			boolean Weight
			boolean weighted
			boolean unweighted
			boolean Search
			boolean BFS
			boolean DFS
			boolean Algorithms
			boolean connected
			boolean stronglyc
			boolean cycle
			boolean mstprim
			boolean mstkruskal
			boolean shortest
		relations:
			R1: common(GPL)
			R2: decomposition(GPL,[Weight, Search], [0,1])
			R3: decomposition(GPL, [Gtp, Algorithms], [1,1])
			R3X: group(Gtp, [directed, undirected], [1,1])
			R4: group(Weight, [weighted, unweighted], [1,1])
			R5: group(Search, [BFS, DFS], [1,1])
			R6: group(Algorithms, [connected, stronglyc, cycle, mstprim, mstkruskal, shortest], [1,*])
			R7: implies(mstprim, unweighted)
			R8: mutex(stronglyc, shortest)
			R9: expression(undirected OR ~mstprim)
			R10: expression(directed OR ~shortest)
			R11: expression( ~mstprim OR ~mstkruskal )
		 	R12: expression( unweighted OR ~mstkruskal )
		 	R13: expression( undirected OR ~stronglyc )
		 	R14: expression( ~connected OR ~stronglyc )
		 	R15: expression( Search OR ~connected )
		 	R16: expression( undirected OR ~mstkruskal )
		 	R17: expression( ~mstkruskal OR ~shortest )
		 	R18: expression( DFS OR ~cycle )
		 	R19: expression( ~mstprim OR ~shortest)
		'''
		//This verifies that the models is syntactically correct
		val model = parseHelper.parse(hlvlProgram)
		Assert.assertNotNull(model)
		printErrors(model)
		
		Assert.assertTrue(model.eResource.errors.isEmpty)
		Assert.assertTrue(model.eResource.errors.isEmpty)	
		
		// Expected code
		val expected=
		'''
		% Autogenerated code form the Coffee framework
		% Author: avillota
		% Variables from elements definitions 
		var 0..1: GPL;
		var 0..1: Gtp;
		var 0..1: directed;
		var 0..1: undirected;
		var 0..1: Weight;
		var 0..1: weighted;
		var 0..1: unweighted;
		var 0..1: Search;
		var 0..1: BFS;
		var 0..1: DFS;
		var 0..1: Algorithms;
		var 0..1: connected;
		var 0..1: stronglyc;
		var 0..1: cycle;
		var 0..1: mstprim;
		var 0..1: mstkruskal;
		var 0..1: shortest;
		% Variables and constraints from the variability relations definition
		constraint GPL == 1;
		constraint GPL >= Weight;
		constraint GPL >= Search;
		constraint GPL == Gtp;
		constraint GPL == Algorithms;
		constraint Gtp <= directed + undirected ;
		constraint directed + undirected  <= Gtp;
		constraint Weight <= weighted + unweighted ;
		constraint weighted + unweighted  <= Weight;
		constraint Search <= BFS + DFS ;
		constraint BFS + DFS  <= Search;
		constraint Algorithms <= connected + stronglyc + cycle + mstprim + mstkruskal + shortest ;
		constraint connected + stronglyc + cycle + mstprim + mstkruskal + shortest  <= 6 * Algorithms;
		constraint mstprim <= unweighted;
		constraint stronglyc + shortest <= 1 ;
		constraint (undirected > 0 \/ not(mstprim > 0));
		constraint (directed > 0 \/ not(shortest > 0));
		constraint (not(mstprim > 0) \/ not(mstkruskal > 0));
		constraint (unweighted > 0 \/ not(mstkruskal > 0));
		constraint (undirected > 0 \/ not(stronglyc > 0));
		constraint (not(connected > 0) \/ not(stronglyc > 0));
		constraint (Search > 0 \/ not(connected > 0));
		constraint (undirected > 0 \/ not(mstkruskal > 0));
		constraint (not(mstkruskal > 0) \/ not(shortest > 0));
		constraint (DFS > 0 \/ not(cycle > 0));
		constraint (not(mstprim > 0) \/ not(shortest > 0));
		% The solving parameters from the parameters files
		'''
		//Obtained code
		val parser= ParserFactory.getParser(Dialect.BASIC_INT, model.name);
		val actual= parser.parseModel(model)
		
		println(actual)
		//Assert
		Assert.assertEquals(expected.toString, actual.toString)
	}
	
/**********************************************************************************************************
* Auxiliar methods for testing
*/

	/**to print the parsing errors */
	def void printErrors(Model model){
		if (!model.eResource.errors.isEmpty){
			for (element : model.eResource.errors) {
				println( element.message)
			}
		}
		
	}
	
}
/**
 * generated by Xtext 2.12.0
 */
package com.coffee.generator;

import com.coffee.generator.JavaCodeStrings;
import com.coffee.tHLCL.And;
import com.coffee.tHLCL.BoolConstant;
import com.coffee.tHLCL.Comparison;
import com.coffee.tHLCL.Constraint;
import com.coffee.tHLCL.DomainDeclaration;
import com.coffee.tHLCL.Enumeration;
import com.coffee.tHLCL.Equality;
import com.coffee.tHLCL.Expression;
import com.coffee.tHLCL.Function;
import com.coffee.tHLCL.Global;
import com.coffee.tHLCL.Iff;
import com.coffee.tHLCL.Implies;
import com.coffee.tHLCL.IntConstant;
import com.coffee.tHLCL.Interval;
import com.coffee.tHLCL.ListOfIDs;
import com.coffee.tHLCL.Minus;
import com.coffee.tHLCL.Model;
import com.coffee.tHLCL.MulOrDiv;
import com.coffee.tHLCL.Negation;
import com.coffee.tHLCL.Or;
import com.coffee.tHLCL.Plus;
import com.coffee.tHLCL.Relational;
import com.coffee.tHLCL.Unary;
import com.coffee.tHLCL.Value;
import com.coffee.tHLCL.Variable;
import com.coffee.tHLCL.VariableRef;
import com.google.common.base.Objects;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class THLCLGenerator extends AbstractGenerator implements JavaCodeStrings {
  private String modelName;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    this.modelName = this.modelName(((Model) _head));
    EObject _head_1 = IterableExtensions.<EObject>head(resource.getContents());
    fsa.generateFile((this.modelName + ".java"), this.toJavaCode(((Model) _head_1)));
  }
  
  public String modelName(final Model model) {
    String name = StringExtensions.toFirstUpper(model.getName());
    return name;
  }
  
  public String className(final Resource res) {
    String name = res.getURI().lastSegment();
    InputOutput.<String>println(name);
    return name.substring(0, name.indexOf("."));
  }
  
  public CharSequence toJavaCode(final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("//Java imports");
    _builder.newLine();
    _builder.append(JavaCodeStrings.JAVA_IMPORTS);
    _builder.newLineIfNotEmpty();
    _builder.append("//imports for hlcl ");
    _builder.newLine();
    _builder.append(JavaCodeStrings.HLCL_IMPORTS);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("//imports for solver");
    _builder.newLine();
    _builder.append(JavaCodeStrings.SOLVER_IMPORTS);
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append(JavaCodeStrings.CLASS_JAVADOC);
    _builder.newLineIfNotEmpty();
    _builder.append(JavaCodeStrings.CLASS_DECLARATION);
    _builder.append(" ");
    _builder.append(this.modelName);
    _builder.append(" { ");
    _builder.append("\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append(JavaCodeStrings.CLASS_ATTRIBUTES, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append(JavaCodeStrings.CONSTRUCTOR_JAVADOC, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("public ");
    _builder.append(this.modelName, "\t");
    _builder.append("(String modelName){ ");
    _builder.append("\t\t\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append(JavaCodeStrings.CONSTRUCTOR_CODE, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("} ");
    _builder.append("\t\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public static void main(String[] args) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append(this.modelName, "\t\t");
    _builder.append(" obj = new ");
    _builder.append(this.modelName, "\t\t");
    _builder.append("(\"");
    _builder.append(this.modelName, "\t\t");
    _builder.append("\");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("obj.run();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append(JavaCodeStrings.RUN_METHOD, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("public void transformVars() {");
    _builder.newLine();
    {
      EList<Variable> _variables = model.getVariables();
      for(final Variable c : _variables) {
        CharSequence _declareVars = this.declareVars(c);
        _builder.append(_declareVars);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void transformConstraints() {");
    _builder.newLine();
    {
      EList<Constraint> _constraints = model.getConstraints();
      for(final Constraint c_1 : _constraints) {
        CharSequence _declareCons = this.declareCons(c_1.getExp(), c_1.getName());
        _builder.append(_declareCons);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append(JavaCodeStrings.EVALUATE_SATISFIABILITY, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append(JavaCodeStrings.GET_VALUE_JAVADOC, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append(JavaCodeStrings.GET_VALUE_CODE, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append(JavaCodeStrings.GETTERS_SETTERS, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("} ");
    _builder.append("\t");
    return _builder;
  }
  
  public CharSequence declareVars(final Variable variable) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("//declaring variable ");
    String _name = variable.getName();
    _builder.append(_name);
    _builder.newLineIfNotEmpty();
    _builder.append("Identifier ");
    String _name_1 = variable.getName();
    _builder.append(_name_1);
    _builder.append(" = factory.newIdentifier(\"");
    String _name_2 = variable.getName();
    _builder.append(_name_2);
    _builder.append("\");");
    _builder.newLineIfNotEmpty();
    String myType = variable.getType().toString();
    _builder.newLineIfNotEmpty();
    CharSequence _declareDomain = this.declareDomain(variable.getDomain(), myType, variable.getName());
    _builder.append(_declareDomain);
    _builder.newLineIfNotEmpty();
    _builder.append("variables.put(\"");
    String _name_3 = variable.getName();
    _builder.append(_name_3);
    _builder.append("\", ");
    String _name_4 = variable.getName();
    _builder.append(_name_4);
    _builder.append("); //including the variable in the map");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareDomain(final DomainDeclaration domain, final String type, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    {
      boolean _equals = Objects.equal(type, "boolean");
      if (_equals) {
        _builder.append("  ");
        _builder.append("\t\t\tBinaryDomain ");
        _builder.append(name);
        _builder.append("Dom= new BinaryDomain();");
        _builder.newLineIfNotEmpty();
      } else {
        {
          if ((domain instanceof Interval)) {
            _builder.append(" ");
            _builder.append("\t\t\t\tRangeDomain ");
            _builder.append(name);
            _builder.append("Dom= new RangeDomain(");
            int _value = ((Interval)domain).getStart().getValue();
            _builder.append(_value);
            _builder.append(", ");
            int _value_1 = ((Interval)domain).getEnd().getValue();
            _builder.append(_value_1);
            _builder.append(");");
            _builder.newLineIfNotEmpty();
          } else {
            {
              if ((domain instanceof Enumeration)) {
                _builder.append(" ");
                _builder.append("\t\t\t\t\t");
                {
                  boolean _equals_1 = type.equals("symbolic");
                  if (_equals_1) {
                    _builder.append(" ");
                    _builder.append("\t\t\t\t\t\tStringDomain ");
                    _builder.append(name);
                    _builder.append("Dom= new StringDomain();");
                    _builder.newLineIfNotEmpty();
                    {
                      EList<Value> _values = ((Enumeration)domain).getList().getValues();
                      for(final Value e : _values) {
                        _builder.append("\t\t");
                        _builder.append(name, "\t\t");
                        _builder.append("Dom.add(\"");
                        _builder.append(e, "\t\t");
                        _builder.append("\"); ");
                        _builder.append("\t\t\t\t\t\t");
                      }
                    }
                    _builder.newLineIfNotEmpty();
                    _builder.append("\t");
                  } else {
                    _builder.append(" ");
                    _builder.append("\t\t\t\t\t\tIntervalDomain ");
                    _builder.append(name);
                    _builder.append("Dom= new IntervalDomain(); ");
                    _builder.newLineIfNotEmpty();
                    {
                      EList<Value> _values_1 = ((Enumeration)domain).getList().getValues();
                      for(final Value e_1 : _values_1) {
                        _builder.append("\t\t");
                        _builder.append(name, "\t\t");
                        _builder.append("Dom.add(");
                        int _value_2 = ((com.coffee.tHLCL.Number) e_1).getValue();
                        _builder.append(_value_2, "\t\t");
                        _builder.append("); ");
                        _builder.append("\t\t\t\t\t\t");
                      }
                    }
                    _builder.newLineIfNotEmpty();
                  }
                }
              }
            }
          }
        }
      }
    }
    _builder.append(name);
    _builder.append(".setDomain(");
    _builder.append(name);
    _builder.append("Dom);\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareCons(final Expression exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("//");
    _builder.newLine();
    _builder.append("//declaring constraint ");
    _builder.append(name);
    _builder.newLineIfNotEmpty();
    {
      if ((exp instanceof Global)) {
        CharSequence _declareGlobal = this.declareGlobal(((Global)exp), name);
        _builder.append(_declareGlobal);
        _builder.newLineIfNotEmpty();
      } else {
        {
          if ((exp instanceof Relational)) {
            CharSequence _declareRelational = this.declareRelational(((Relational)exp), name);
            _builder.append(_declareRelational);
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    _builder.append("constraints.put(\"");
    _builder.append(name);
    _builder.append("\", ");
    _builder.append(name);
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.append("hlclProgram.add(");
    _builder.append(name);
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareGlobal(final Global exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("SymbolicExpression ");
    _builder.append(name);
    _builder.append("= factory.newSymbolic(\"");
    String _op = exp.getOp();
    _builder.append(_op);
    _builder.append("\"");
    CharSequence _declareIds = this.declareIds(exp.getVars());
    _builder.append(_declareIds);
    _builder.append(");");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence declareIds(final ListOfIDs idList) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<String> _ids = idList.getIds();
      for(final String id : _ids) {
        _builder.append(", variables.get(\"");
        _builder.append(id);
        _builder.append("\")");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence declareRelational(final Relational exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    {
      if ((exp instanceof BoolConstant)) {
        {
          String _value = ((BoolConstant)exp).getValue();
          boolean _equals = Objects.equal(_value, "true");
          if (_equals) {
            _builder.append("NumericIdentifier ");
            _builder.append(name);
            _builder.append("=getValue(\"1\");");
            _builder.newLineIfNotEmpty();
          } else {
            _builder.append("NumericIdentifier ");
            _builder.append(name);
            _builder.append("=getValue(\"0\");");
            _builder.newLineIfNotEmpty();
          }
        }
      } else {
        {
          if ((exp instanceof IntConstant)) {
            _builder.append("NumericIdentifier ");
            _builder.append(name);
            _builder.append(" = getValue(\"");
            int _value_1 = ((IntConstant)exp).getValue();
            _builder.append(_value_1);
            _builder.append("\");");
            _builder.newLineIfNotEmpty();
          } else {
            {
              if ((exp instanceof VariableRef)) {
                _builder.append("Identifier ");
                _builder.append(name);
                _builder.append(" = variables.get(\"");
                String _name = ((VariableRef)exp).getVariable().getName();
                _builder.append(_name);
                _builder.append("\");");
                _builder.newLineIfNotEmpty();
              } else {
                {
                  if ((exp instanceof Function)) {
                    CharSequence _declareFunction = this.declareFunction(((Function)exp), name);
                    _builder.append(_declareFunction);
                    _builder.newLineIfNotEmpty();
                  } else {
                    {
                      if ((exp instanceof Unary)) {
                        CharSequence _declareUnary = this.declareUnary(((Unary)exp), name);
                        _builder.append(_declareUnary);
                        _builder.newLineIfNotEmpty();
                      } else {
                        {
                          if ((exp instanceof Negation)) {
                            CharSequence _declareNegation = this.declareNegation(((Negation)exp), name);
                            _builder.append(_declareNegation);
                            _builder.newLineIfNotEmpty();
                          } else {
                            {
                              if ((exp instanceof MulOrDiv)) {
                                CharSequence _declareMulOrDiv = this.declareMulOrDiv(((MulOrDiv)exp), name);
                                _builder.append(_declareMulOrDiv);
                                _builder.newLineIfNotEmpty();
                              } else {
                                {
                                  if ((exp instanceof Plus)) {
                                    CharSequence _declarePlus = this.declarePlus(((Plus)exp), name);
                                    _builder.append(_declarePlus);
                                    _builder.newLineIfNotEmpty();
                                  } else {
                                    {
                                      if ((exp instanceof Minus)) {
                                        CharSequence _declareMinus = this.declareMinus(((Minus)exp), name);
                                        _builder.append(_declareMinus);
                                        _builder.newLineIfNotEmpty();
                                      } else {
                                        {
                                          if ((exp instanceof Comparison)) {
                                            CharSequence _declareComparison = this.declareComparison(((Comparison)exp), name);
                                            _builder.append(_declareComparison);
                                            _builder.newLineIfNotEmpty();
                                          } else {
                                            {
                                              if ((exp instanceof Equality)) {
                                                CharSequence _declareEquality = this.declareEquality(((Equality)exp), name);
                                                _builder.append(_declareEquality);
                                                _builder.newLineIfNotEmpty();
                                              } else {
                                                {
                                                  if ((exp instanceof And)) {
                                                    CharSequence _declareAnd = this.declareAnd(((And)exp), name);
                                                    _builder.append(_declareAnd);
                                                    _builder.newLineIfNotEmpty();
                                                  } else {
                                                    {
                                                      if ((exp instanceof Or)) {
                                                        CharSequence _declareOr = this.declareOr(((Or)exp), name);
                                                        _builder.append(_declareOr);
                                                        _builder.newLineIfNotEmpty();
                                                      } else {
                                                        {
                                                          if ((exp instanceof Implies)) {
                                                            CharSequence _declareImplies = this.declareImplies(((Implies)exp), name);
                                                            _builder.append(_declareImplies);
                                                            _builder.newLineIfNotEmpty();
                                                          } else {
                                                            {
                                                              if ((exp instanceof Iff)) {
                                                                CharSequence _declareIff = this.declareIff(((Iff)exp), name);
                                                                _builder.append(_declareIff);
                                                                _builder.newLineIfNotEmpty();
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence declareFunction(final Function exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// ");
    _builder.append(name);
    _builder.append(" to be implemented in Variamos HLCL");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareUnary(final Unary exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("// ");
    _builder.append(name);
    _builder.append(" to be implemented in Variamos HLCL");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareNegation(final Negation exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getExpression(), (name + "_negation"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    _builder.append("IntBooleanExpression ");
    _builder.append(name);
    _builder.append("=factory.not(");
    _builder.append(name);
    _builder.append("_negation);");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareMulOrDiv(final MulOrDiv exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntNumericExpression ");
    _builder.append(name);
    _builder.append("=");
    _builder.newLineIfNotEmpty();
    {
      String _op = exp.getOp();
      boolean _equals = Objects.equal(_op, "*");
      if (_equals) {
        _builder.append("factory.prod(");
        _builder.append(name);
        _builder.append("_left, ");
        _builder.append(name);
        _builder.append("_right);");
        _builder.newLineIfNotEmpty();
      } else {
        {
          String _op_1 = exp.getOp();
          boolean _equals_1 = Objects.equal(_op_1, "/");
          if (_equals_1) {
            _builder.append("// ");
            _builder.append(name);
            _builder.append(" to be implemented in Variamos HLCL");
            _builder.newLineIfNotEmpty();
            _builder.append("//factory.div(");
            _builder.append(name);
            _builder.append("_left, ");
            _builder.append(name);
            _builder.append("_right);");
            _builder.newLineIfNotEmpty();
          } else {
            {
              String _op_2 = exp.getOp();
              boolean _equals_2 = Objects.equal(_op_2, "mod");
              if (_equals_2) {
                _builder.append("// ");
                _builder.append(name);
                _builder.append(" to be implemented in Variamos HLCL");
                _builder.newLineIfNotEmpty();
                _builder.append("//factory.div(");
                _builder.append(name);
                _builder.append("_left, ");
                _builder.append(name);
                _builder.append("_right);");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence declarePlus(final Plus exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntNumericExpression ");
    _builder.append(name);
    _builder.append("=factory.sum(");
    _builder.append(name);
    _builder.append("_left, ");
    _builder.append(name);
    _builder.append("_right);\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareMinus(final Minus exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntNumericExpression ");
    _builder.append(name);
    _builder.append("=factory.diff(");
    _builder.append(name);
    _builder.append("_left, ");
    _builder.append(name);
    _builder.append("_right);\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareEquality(final Equality exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntBooleanExpression ");
    _builder.append(name);
    _builder.append("=");
    _builder.newLineIfNotEmpty();
    {
      String _op = exp.getOp();
      boolean _equals = Objects.equal(_op, "=");
      if (_equals) {
        _builder.append("factory.equals(");
        _builder.append(name);
        _builder.append("_left, ");
        _builder.append(name);
        _builder.append("_right);");
        _builder.newLineIfNotEmpty();
      } else {
        {
          String _op_1 = exp.getOp();
          boolean _equals_1 = Objects.equal(_op_1, "!=");
          if (_equals_1) {
            _builder.append("factory.notEquals(");
            _builder.append(name);
            _builder.append("_left, ");
            _builder.append(name);
            _builder.append("_right);");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence declareComparison(final Comparison exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntBooleanExpression ");
    _builder.append(name);
    _builder.append("=");
    _builder.newLineIfNotEmpty();
    {
      String _op = exp.getOp();
      boolean _equals = Objects.equal(_op, ">");
      if (_equals) {
        _builder.append("factory.greaterThan(");
        _builder.append(name);
        _builder.append("_left, ");
        _builder.append(name);
        _builder.append("_right);");
        _builder.newLineIfNotEmpty();
      } else {
        {
          String _op_1 = exp.getOp();
          boolean _equals_1 = Objects.equal(_op_1, ">=");
          if (_equals_1) {
            _builder.append("factory.greaterOrEqualsThan(");
            _builder.append(name);
            _builder.append("_left, ");
            _builder.append(name);
            _builder.append("_right);");
            _builder.newLineIfNotEmpty();
          } else {
            {
              String _op_2 = exp.getOp();
              boolean _equals_2 = Objects.equal(_op_2, "<");
              if (_equals_2) {
                _builder.append("factory.lessThan(");
                _builder.append(name);
                _builder.append("_left, ");
                _builder.append(name);
                _builder.append("_right);");
                _builder.newLineIfNotEmpty();
              } else {
                {
                  String _op_3 = exp.getOp();
                  boolean _equals_3 = Objects.equal(_op_3, "<=");
                  if (_equals_3) {
                    _builder.append("factory.lessOrEqualsThan(");
                    _builder.append(name);
                    _builder.append("_left, ");
                    _builder.append(name);
                    _builder.append("_right);");
                    _builder.newLineIfNotEmpty();
                  } else {
                    {
                      String _op_4 = exp.getOp();
                      boolean _equals_4 = Objects.equal(_op_4, "=");
                      if (_equals_4) {
                        _builder.append("factory.equals(");
                        _builder.append(name);
                        _builder.append("_left, ");
                        _builder.append(name);
                        _builder.append("_right);");
                        _builder.newLineIfNotEmpty();
                      } else {
                        {
                          String _op_5 = exp.getOp();
                          boolean _equals_5 = Objects.equal(_op_5, "!=");
                          if (_equals_5) {
                            _builder.append("factory.notEquals(");
                            _builder.append(name);
                            _builder.append("_left, ");
                            _builder.append(name);
                            _builder.append("_right);");
                            _builder.newLineIfNotEmpty();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence declareAnd(final And exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntBooleanExpression ");
    _builder.append(name);
    _builder.append("=factory.and(");
    _builder.append(name);
    _builder.append("_left, ");
    _builder.append(name);
    _builder.append("_right);\t\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareOr(final Or exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntBooleanExpression ");
    _builder.append(name);
    _builder.append("=factory.or(");
    _builder.append(name);
    _builder.append("_left, ");
    _builder.append(name);
    _builder.append("_right);\t\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareImplies(final Implies exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntBooleanExpression ");
    _builder.append(name);
    _builder.append("=factory.implies(");
    _builder.append(name);
    _builder.append("_left, ");
    _builder.append(name);
    _builder.append("_right);\t\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareIff(final Iff exp, final String name) {
    StringConcatenation _builder = new StringConcatenation();
    Object _declareRelational = this.declareRelational(exp.getLeft(), (name + "_left"));
    _builder.append(_declareRelational);
    _builder.newLineIfNotEmpty();
    Object _declareRelational_1 = this.declareRelational(exp.getRight(), (name + "_right"));
    _builder.append(_declareRelational_1);
    _builder.newLineIfNotEmpty();
    _builder.append("IntBooleanExpression ");
    _builder.append(name);
    _builder.append("=factory.doubleImplies(");
    _builder.append(name);
    _builder.append("_left, ");
    _builder.append(name);
    _builder.append("_right);\t\t");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
}

/**
 * generated by Xtext 2.12.0
 */
package com.coffee.validation;

import com.coffee.tHLCL.And;
import com.coffee.tHLCL.Constraint;
import com.coffee.tHLCL.DomainDeclaration;
import com.coffee.tHLCL.Expression;
import com.coffee.tHLCL.Iff;
import com.coffee.tHLCL.Implies;
import com.coffee.tHLCL.Negation;
import com.coffee.tHLCL.Or;
import com.coffee.tHLCL.THLCLPackage;
import com.coffee.tHLCL.Variable;
import com.coffee.tHLCL.VariableRef;
import com.coffee.typing.ExpressionsType;
import com.coffee.typing.TypeProvider;
import com.coffee.util.THlclUtil;
import com.coffee.validation.AbstractTHLCLValidator;
import com.google.common.base.Objects;
import com.google.inject.Inject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class THLCLValidator extends AbstractTHLCLValidator {
  public final static String FORWARD_REFERENCE = "org.example.expressions.ForwardReference";
  
  public final static String WRONG_TYPE = "org.example.expressions.WrongType";
  
  @Inject
  @Extension
  private TypeProvider _typeProvider;
  
  private final static THLCLPackage packageInstance = THLCLPackage.eINSTANCE;
  
  /**
   * Method for checking that non boolean domains are correctly declarated
   */
  @Check
  public void checkTypeForNonBooleanDomain(final Variable decl) {
    String _type = decl.getType();
    boolean _equals = Objects.equal(_type, "boolean");
    if (_equals) {
      return;
    } else {
      DomainDeclaration _domain = decl.getDomain();
      boolean _tripleEquals = (_domain == null);
      if (_tripleEquals) {
        String _name = decl.getName();
        String _plus = ("A domain declaration is required for variable \'" + _name);
        String _plus_1 = (_plus + "\'");
        this.error(_plus_1, 
          THLCLValidator.packageInstance.getVariable_Domain());
        return;
      }
    }
  }
  
  /**
   * Method for checking that a variable is already declarated
   */
  @Check
  public void checkVarDeclaration(final VariableRef varRef) {
    final Variable variable = varRef.getVariable();
    if (((variable != null) && (!THlclUtil.variableIsDefinedBefore(variable)))) {
      String _name = variable.getName();
      String _plus = ("Variables should be declared before being used: \'" + _name);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, 
        THLCLValidator.packageInstance.getVariableRef_Variable(), THLCLValidator.FORWARD_REFERENCE, variable.getName());
    }
  }
  
  /**
   * To verify types in the language
   */
  private void checkExpectedType(final Expression exp, final ExpressionsType expectedType, final EReference reference) {
    final ExpressionsType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, THLCLValidator.WRONG_TYPE);
    }
  }
  
  private ExpressionsType getTypeAndCheckNotNull(final Expression exp, final EReference reference) {
    ExpressionsType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._typeProvider.typeFor(exp);
    }
    ExpressionsType type = _typeFor;
    if ((type == null)) {
      this.error("null type", reference, THLCLValidator.WRONG_TYPE);
    }
    return type;
  }
  
  private void checkExpectedBoolean(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, TypeProvider.boolType, reference);
  }
  
  private void checkExpectedInt(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, TypeProvider.intType, reference);
  }
  
  /**
   * Checking the type of logic expressions
   */
  @Check
  public void checkType(final Negation not) {
    this.checkExpectedBoolean(not.getExpression(), THLCLValidator.packageInstance.getNegation_Expression());
  }
  
  @Check
  public void checkType(final And and) {
    this.checkExpectedBoolean(and.getLeft(), THLCLValidator.packageInstance.getAnd_Left());
    this.checkExpectedBoolean(and.getRight(), THLCLValidator.packageInstance.getAnd_Right());
  }
  
  @Check
  public void checkType(final Or or) {
    this.checkExpectedBoolean(or.getLeft(), THLCLValidator.packageInstance.getOr_Left());
    this.checkExpectedBoolean(or.getRight(), THLCLValidator.packageInstance.getOr_Right());
  }
  
  @Check
  public void checkType(final Implies imp) {
    this.checkExpectedBoolean(imp.getLeft(), THLCLValidator.packageInstance.getImplies_Left());
    this.checkExpectedBoolean(imp.getRight(), THLCLValidator.packageInstance.getImplies_Right());
  }
  
  @Check
  public void checkType(final Iff iff) {
    this.checkExpectedBoolean(iff.getLeft(), THLCLValidator.packageInstance.getIff_Left());
    this.checkExpectedBoolean(iff.getRight(), THLCLValidator.packageInstance.getIff_Right());
  }
  
  @Check
  public void checkType(final Constraint cons) {
    this.checkExpectedBoolean(cons.getExp(), THLCLValidator.packageInstance.getConstraint_Exp());
  }
}

/*
 * generated by Xtext 2.12.0
 */
package com.coffee.tests


import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import com.coffee.pLEC.Model
import com.coffee.pLEC.PLECPackage

/**
 * Class to test the product lines grammar and its parsing
 * @author Angela Villota
 * @version PLEC V3
 * August 2018
 */

@RunWith(XtextRunner)
@InjectWith(PLECInjectorProvider)
class PLECParsingTest {
	@Inject
	ParseHelper<Model> parseHelper
	@Inject extension ParseHelper // gracias a esta linea se puede hacer el llamado .parse
	@Inject extension ValidationTestHelper
	

/*********************************************************************************************************
 * Methods to test the parser
 * 
 */
 /**
 * Method to test the interpretation of an empty program
 */
	@Test
	def void emptyModel() {
		// model is a program in PLEC
		val model = 
		'''
		model empty
		variables:
		constraints:
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}
	
/**
 * Declaring a boolean var without domain
 */
	@Test
	def void booleanVar() {
		// model is a program in PLEC
		val model = 
		'''
		model m1
		variables:
		boolean A 
		constraints:
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}

/**
 * Declaring an integer var with an enumeration
 */
	@Test
	def void integerVarEnum() {
		// model is a program in PLEC
		val model = 
		'''
		model m1
		variables:
		integer A values: [10, 20, 30, 40]
		constraints:
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}

/**
 * Declaring an integer var with an enumeration
 */
	@Test
	def void integerVarInterval() {
		// model is a program in PLEC
		val model = 
		'''
		model m1
		variables:
		integer A values: 1..100
		constraints:
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}
	
/**
 * Declaring boolean instanciable variables
 */
	@Test
	def void boolInstantiable() {
		// model is a program in PLEC
		val model = 
		'''
		model m1
		variables:
		instantiable [2,5] boolean A
		constraints:
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		printErrors(empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
		
	}
/**
 * Declaring integer instantiable  variable with an interval domain
 */
	@Test
	def void integerIntervalInstantiable() {
		// model is a program in PLEC
		val model = 
		'''
		model m1
		variables:
		instantiable [2,5] integer A values: 1..100 
		constraints:
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}

/**
 * Declaring integer instantiable variable with an enumeration domain
 */
	@Test
	def void integerEnumerationInstantiable() {
		// model is a program in PLEC
		val model = 
		'''
		model m1
		variables:
		instantiable [2,5] integer A values: [10, 20, 30, 40] 
		constraints:
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
		printErrors( empty)
	}

/**
 * Declaring structural relations
 */
	@Test
	def void structural() {
		// model is a program in PLEC
		val model = 
		'''
		model m1
		variables:
		boolean GPL
		boolean GType
		boolean Weight
		boolean Search
		boolean Algorithms
		constraints:
		c1: structural: GPL variants: [GType, GPL, Weight, Search, Algorithms] 
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		printErrors( empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}

	@Test
	def void structuralCard() {
		// model is a program in PLEC
		val model = 
		'''
		model GPL
		variables:
		boolean GType
		boolean Weight
		boolean Search
		boolean Algorithms
		constraints:
		c1: structural: GPL variants: [GType, GPL, Weight, Search, Algorithms] card:[1,1]
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		printErrors( empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}
		
	/**
	 * Testing mandatory and optional in a parent-child relation
	 */
	@Test
	def void parentChildOperations() {
		// model is a program in HLVL
		val model = 
		'''
		model GPL
		variables:
		boolean GType
		boolean Weight
		boolean Search
		boolean Algorithms
		constraints:
		c1: structural: GPL variants: [GType, GPL, Weight, Search, Algorithms] card:[1,1]
		c2: GType is optional
		C3: Weight is mandatory
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		printErrors( empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}
	/**
	 * Refinement - root
	 */
	 	@Test
	def void refinementRoot() {
		// model is a program in HLVL
		val model = 
		'''
		model GPL
		variables:
		boolean GType
		boolean Weight
		boolean Search
		boolean Algorithms
		constraints:
		c1: GPL is root
		'''
		//empty is an empty model
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		printErrors( empty)
		Assert.assertTrue(empty.eResource.errors.isEmpty)
	}
	

/**
 * Declaring attributes
 */
	@Test
	def void attributes() {
		// model is a program in HLVL
		val model = 
		'''
		model m1
		variables:
		boolean GPL
		boolean GType
		boolean Weight
		boolean Search
		boolean Algorithms
		integer Memory values: [2, 4, 8, 16, 32]
		constraints:
		c1: attributes: [Memory] of Search 
		'''
		
		val empty = parseHelper.parse(model)
		Assert.assertNotNull(empty)
		printErrors( empty)
		assertNoErrors(empty)
			}


/**
 * Declaring requires relations
 */
 	@Test
	def void requires() {
		// model is a program in HLVL
		val program = 
		'''
		model GPL
		variables:
		boolean GType
		boolean Weight
		boolean Search
		boolean Algorithms
		constraints:
		c1: GType requires Search
		'''
		
		val model = parseHelper.parse(program)
		Assert.assertNotNull(model)
		printErrors(model)
		Assert.assertTrue(model.eResource.errors.isEmpty)
	}
 /**
 * Declaring excludes relations
 */
 	 	@Test
	def void excludes() {
		// model is a program in HLVL
		val program = 
		'''
		model GPL
		variables:
		boolean GType
		boolean Weight
		boolean Search
		boolean Algorithms
		constraints:
		c1: GType excludes Search
		'''
		
		val model = parseHelper.parse(program)
		Assert.assertNotNull(model)
		printErrors(model)
		assertNoErrors(model)
		//Assert.assertTrue(model.eResource.errors.isEmpty)
	}
	
	/** Quantifiable requires */
	 @Test
	def void quantifiableRequires() {
		// model is a program in HLVL
		val program = 
		'''
		model Modelo
		variables: 
		boolean GPL
		instantiable[1,10] boolean GType
		instantiable[0,5] boolean Algorithms
		constraints:
		c1: GPL is root
		c2: structural: GPL variants: [GType, Algorithms] card:[1,2]
		c3: [5,8] GType requires [2,4] Algorithms
		'''
		val m1 = parseHelper.parse(program)
		Assert.assertNotNull(m1)
		assertNoErrors(m1)
	}
	
	/**
	 * Refinement - value
	 */
	 
	 @Test
	def void refinementValue() {
		// model is a program in HLVL
		val program = 
		'''
		model Modelo
		variables:
		boolean GPL
		integer Memory values: [2, 4, 8, 16, 32]
		constraints:
		c1: GPL is selected
		c2: Memory is 16
		'''
		val m1 = parseHelper.parse(program)
		Assert.assertNotNull(m1)
		assertNoErrors(m1)
	}
	
	/**
	 * Refinement - value
	 */
	 @Test
	def void refinementSet() {
		// model is a program in HLVL
		val model = 
		'''
		model MCS
		variables:
		boolean GType
		boolean Weight
		boolean Search
		integer Cores values: 0..7
		integer Memory values: [0, 2, 4, 8, 16, 32]
		constraints:
		c1: vars: (Cores, Memory) variants: [(1,2), (2, 4), (4, 16), (5, 32)]
		c2: Memory is 16
		'''
		val m1 = parseHelper.parse(model)
		Assert.assertNotNull(m1)
		assertNoErrors(m1)
		printErrors(m1)
		//Assert.assertTrue(m1.eResource.errors.isEmpty)
	}
	/**
	 * Rule - value
	 */
	 @Test
	def void rule() {
		// model is a program in HLVL
		val model = 
		'''
		model MCS
		variables:
		boolean GType
		boolean Weight
		boolean Search
		integer Cores values: 0..7
		integer Memory values: [0, 2, 4, 8, 16, 32]
		constraints:
		c1: vars: (Cores, Memory) variants: [(1,2), (2, 4), (4, 16), (5, 32)]
		c2: Memory is 16
		rule1: c1--> c2
		rule2: (GType is selected) --> (Weight is selected)
		'''
		val m1 = parseHelper.parse(model)
		Assert.assertNotNull(m1)
		assertNoErrors(m1)
		printErrors(m1)
		//Assert.assertTrue(m1.eResource.errors.isEmpty)
	}
	/**
	 * Rule - value
	 */
	@Test
	def void temporal() {
		// model is a program in HLVL
		val model = 
		'''
		model MCS
		variables:
		boolean GType
		boolean Weight
		boolean Search
		integer Cores values: 0..7
		integer Memory values: [0, 2, 4, 8, 16, 32]
		constraints:
		c1: vars: (Cores, Memory) variants: [(1,2), (2, 4), (4, 16), (5, 32)]
		c2: Memory is 16
		rule1: c1--> c2
		rule2: (GType is selected) --> (Weight is selected)
		tmp1: always c1
		tmp2: next c2
		tmp3: eventually(Memory is 16) 
		'''
		val m1 = parseHelper.parse(model)
		Assert.assertNotNull(m1)
		assertNoErrors(m1)
		printErrors(m1)
		//Assert.assertTrue(m1.eResource.errors.isEmpty)
	}
/*****************************************************************************************************
 * Testing errors and validations
 */
	@Test
	def void integerNoDomainError(){
		val model= 
		'''
		model m1
		variables:
		integer A 
		constraints: 
		'''.parse
		model.assertError(PLECPackage::eINSTANCE.varDeclaration, 
			null,
			 "A variants declaration is required for variable 'A'"
		)
	}
	
		@Test
	def void stringNoDomainError(){
		val model= 
		'''
		model m1
		variables:
		symbolic A 
		constraints: 
		'''.parse
		model.assertError(PLECPackage::eINSTANCE.varDeclaration, 
			null,
			 "A variants declaration is required for variable 'A'"
		)
	}
/**********************************************************************************************************
* Auxiliar methods for testing
*/

	/**to print the parsing errors */
	def void printErrors(Model model){
		if (!model.eResource.errors.isEmpty){
			for (element : model.eResource.errors) {
				println( element.message)
			}
		}
		
	}
}

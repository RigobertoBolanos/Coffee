package com.coffee.generator;

import com.coffee.generator.CodeFactory;
import com.coffee.generator.Dialect;
import com.coffee.generator.IGenerator;
import com.coffee.hlvl.ConstantDecl;
import com.coffee.hlvl.Core;
import com.coffee.hlvl.Declaration;
import com.coffee.hlvl.Decomposition;
import com.coffee.hlvl.ElmDeclaration;
import com.coffee.hlvl.Expression;
import com.coffee.hlvl.Group;
import com.coffee.hlvl.Model;
import com.coffee.hlvl.Pair;
import com.coffee.hlvl.RelDeclaration;
import com.coffee.hlvl.Relation;
import com.coffee.hlvl.VarList;
import com.coffee.hlvl.VariableDecl;
import com.coffee.hlvl.Visibility;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.InputOutput;

/**
 * Abstract Generator, this is the class that process the model and traverses the
 * syntax tree regardless the type of notation and problem
 * @author Angela Villota
 * @version HLVL 1
 * August 2018
 * adpated to the HLVl grammar on January 2019
 */
@SuppressWarnings("all")
public abstract class AbstractGenerator implements IGenerator {
  /**
   * Name of the PL model
   */
  private String modelName;
  
  private Dialect dialect;
  
  /**
   * object to obtain the program sentences regarding the type of the problem
   */
  private CodeFactory factory;
  
  /**
   * Map with the parent of each variable, for decomposition relations
   */
  private Map<String, ElmDeclaration> parents;
  
  /**
   * Map with the parent of each variable, for decomposition relations
   */
  private Map<String, Relation> relations;
  
  private Map<String, ElmDeclaration> attributes;
  
  /**
   * Constructor method
   * @param the name of the model
   * @param type of the problem
   */
  public AbstractGenerator(final String name, final Dialect dialect) {
    this.modelName = name;
    this.dialect = dialect;
    HashMap<String, ElmDeclaration> _hashMap = new HashMap<String, ElmDeclaration>();
    this.parents = _hashMap;
    HashMap<String, ElmDeclaration> _hashMap_1 = new HashMap<String, ElmDeclaration>();
    this.attributes = _hashMap_1;
    HashMap<String, Relation> _hashMap_2 = new HashMap<String, Relation>();
    this.relations = _hashMap_2;
  }
  
  /**
   * Method to obtain a sequence of characters containing the constraint
   * representation of the model regarding the type of the problem and the
   * notation.
   * @param model is an ECORE syntax tree with the program
   * this syntax tree should be traversed.
   */
  @Override
  public CharSequence parseModel(final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("% Autogenerated code form the Coffee framework");
    _builder.newLine();
    _builder.append("% Author: avillota");
    _builder.newLine();
    _builder.append("% Variables from elements definitions ");
    _builder.newLine();
    CharSequence _parseElements = this.parseElements(model);
    _builder.append(_parseElements);
    _builder.newLineIfNotEmpty();
    _builder.append("% Variables and constraints from the variability relations definition");
    _builder.newLine();
    CharSequence _parseRelations = this.parseRelations(model);
    _builder.append(_parseRelations);
    _builder.newLineIfNotEmpty();
    _builder.append("% The solving parameters from the parameters files");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * This method traverses the list of variables to parse each declaration
   * The declaration is made by the factory
   * @param model
   */
  @Override
  public CharSequence parseElements(final Model model) {
    String _xblockexpression = null;
    {
      String out = "";
      EList<ElmDeclaration> _elements = model.getElements();
      for (final ElmDeclaration element : _elements) {
        if (((element.getAtt() != null) && Objects.equal(element.getAtt(), "att"))) {
          this.attributes.put(element.getName(), element);
        } else {
          Declaration _declaration = element.getDeclaration();
          if ((_declaration instanceof ConstantDecl)) {
            Declaration _declaration_1 = element.getDeclaration();
            final int value = ((ConstantDecl) _declaration_1).getValue();
            if ((Objects.equal(element.getDataType(), "boolean") && (value == 0))) {
              String _out = out;
              CharSequence _element = this.factory.getElement(element);
              out = (_out + _element);
            } else {
              String _out_1 = out;
              CharSequence _constant = this.factory.getConstant(element);
              out = (_out_1 + _constant);
            }
          } else {
            Declaration _declaration_2 = element.getDeclaration();
            if ((_declaration_2 instanceof VariableDecl)) {
              String _out_2 = out;
              CharSequence _element_1 = this.factory.getElement(element);
              out = (_out_2 + _element_1);
            }
          }
        }
      }
      _xblockexpression = out;
    }
    return _xblockexpression;
  }
  
  /**
   * Method to parse the constraints in a model.
   * The constraints are contained in a collection
   * of constraints
   * @param model
   */
  @Override
  public CharSequence parseRelations(final Model model) {
    String _xblockexpression = null;
    {
      String out = "";
      InputOutput.<String>println("call to parseRelations");
      EList<RelDeclaration> _relations = model.getRelations();
      for (final RelDeclaration e : _relations) {
        {
          this.relations.put(e.getName(), e.getExp());
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("parsing relation ");
          String _name = e.getName();
          _builder.append(_name);
          InputOutput.<String>println(_builder.toString());
          String _out = out;
          CharSequence _parseRelation = this.parseRelation(e.getExp());
          out = (_out + _parseRelation);
        }
      }
      InputOutput.<String>println(("parseRelation out " + out));
      _xblockexpression = out;
    }
    return _xblockexpression;
  }
  
  /**
   * This method is used to determine he type of an expression and
   * call the method in charge to produce the code.
   * @param exp is a constraint expression
   */
  @Override
  public CharSequence parseRelation(final Relation rel) {
    CharSequence _xifexpression = null;
    if ((rel instanceof Core)) {
      _xifexpression = this.factory.getCore(((Core)rel));
    } else {
      CharSequence _xifexpression_1 = null;
      if ((rel instanceof Decomposition)) {
        _xifexpression_1 = this.factory.getDecomposition(((Decomposition)rel), this.parents);
      } else {
        CharSequence _xifexpression_2 = null;
        if ((rel instanceof Group)) {
          _xifexpression_2 = this.factory.getGroup(((Group)rel), this.parents);
        } else {
          CharSequence _xifexpression_3 = null;
          if ((rel instanceof Pair)) {
            CharSequence _xblockexpression = null;
            {
              final Pair pair = ((Pair) rel);
              CharSequence _xifexpression_4 = null;
              String _operator = pair.getOperator();
              boolean _equals = Objects.equal(_operator, "implies");
              if (_equals) {
                _xifexpression_4 = this.factory.getImpliesPair(((Pair)rel).getVar1(), ((Pair)rel).getVar2());
              } else {
                _xifexpression_4 = this.factory.getMutexPair(((Pair)rel).getVar1(), ((Pair)rel).getVar2());
              }
              _xblockexpression = _xifexpression_4;
            }
            _xifexpression_3 = _xblockexpression;
          } else {
            CharSequence _xifexpression_4 = null;
            if ((rel instanceof VarList)) {
              CharSequence _xblockexpression_1 = null;
              {
                final Pair pair = ((Pair) rel);
                CharSequence _xifexpression_5 = null;
                String _operator = pair.getOperator();
                boolean _equals = Objects.equal(_operator, "implies");
                if (_equals) {
                  _xifexpression_5 = this.factory.getImpliesList(((VarList)rel));
                } else {
                  _xifexpression_5 = this.factory.getMutexList(((VarList)rel));
                }
                _xblockexpression_1 = _xifexpression_5;
              }
              _xifexpression_4 = _xblockexpression_1;
            } else {
              CharSequence _xifexpression_5 = null;
              if ((rel instanceof Expression)) {
                _xifexpression_5 = this.factory.getExpression(((Expression)rel).getExp());
              } else {
                CharSequence _xifexpression_6 = null;
                if ((rel instanceof Visibility)) {
                  CharSequence _xblockexpression_2 = null;
                  {
                    ArrayList<CharSequence> relations = new ArrayList<CharSequence>();
                    EList<RelDeclaration> _ids = ((Visibility)rel).getChildren().getIds();
                    for (final RelDeclaration r : _ids) {
                      relations.add(this.parseRelation(r.getExp()));
                    }
                    _xblockexpression_2 = this.factory.getVisibility(((Visibility)rel), relations);
                  }
                  _xifexpression_6 = _xblockexpression_2;
                }
                _xifexpression_5 = _xifexpression_6;
              }
              _xifexpression_4 = _xifexpression_5;
            }
            _xifexpression_3 = _xifexpression_4;
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  /**
   * ===================================================================
   * ===================================================================
   *  Getters and setters
   */
  @Override
  public String getModelName() {
    return this.modelName;
  }
  
  @Override
  public Dialect getDialect() {
    return this.dialect;
  }
  
  @Override
  public void addParents(final Decomposition exp) {
    EList<ElmDeclaration> _values = exp.getChildren().getValues();
    for (final ElmDeclaration element : _values) {
      this.parents.put(element.getName(), exp.getParent());
    }
  }
  
  @Override
  public Map<String, ElmDeclaration> getParents() {
    return this.parents;
  }
  
  @Override
  public void setFactory(final CodeFactory factory) {
    this.factory = factory;
  }
}

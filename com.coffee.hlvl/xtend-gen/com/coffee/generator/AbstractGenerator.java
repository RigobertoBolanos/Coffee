package com.coffee.generator;

import com.coffee.generator.CodeFactory;
import com.coffee.generator.Dialect;
import com.coffee.generator.IGenerator;
import com.coffee.hlvl.ComplexImplies;
import com.coffee.hlvl.ConstantDecl;
import com.coffee.hlvl.Core;
import com.coffee.hlvl.Declaration;
import com.coffee.hlvl.Decomposition;
import com.coffee.hlvl.ElmDeclaration;
import com.coffee.hlvl.Expression;
import com.coffee.hlvl.Group;
import com.coffee.hlvl.Model;
import com.coffee.hlvl.MultInstantiation;
import com.coffee.hlvl.Pair;
import com.coffee.hlvl.QImplies;
import com.coffee.hlvl.RelDeclaration;
import com.coffee.hlvl.Relation;
import com.coffee.hlvl.Value;
import com.coffee.hlvl.VarList;
import com.coffee.hlvl.VariableDecl;
import com.coffee.hlvl.Visibility;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;

/**
 * Abstract Generator, this is the class that process the model and traverses the
 * syntax tree regardless the type of notation and problem
 * @author Angela Villota
 * @version HLVL 1
 * August 2018
 * adpated to the HLVl grammar on January 2019
 */
@SuppressWarnings("all")
public abstract class AbstractGenerator implements IGenerator {
  /**
   * Name of the PL model
   */
  private String modelName;
  
  private Dialect dialect;
  
  /**
   * object to obtain the program sentences regarding the type of the problem
   */
  private CodeFactory factory;
  
  /**
   * Map with the parent of each variable, for decomposition relations
   */
  private Map<String, ElmDeclaration> parents;
  
  /**
   * Map with the parent of each variable, for decomposition relations
   */
  private Map<String, Relation> relations;
  
  private Map<String, ElmDeclaration> attributes;
  
  /**
   * Constructor method
   * @param the name of the model
   * @param type of the problem
   */
  public AbstractGenerator(final String name, final Dialect dialect) {
    this.modelName = name;
    this.dialect = dialect;
    HashMap<String, ElmDeclaration> _hashMap = new HashMap<String, ElmDeclaration>();
    this.parents = _hashMap;
    HashMap<String, ElmDeclaration> _hashMap_1 = new HashMap<String, ElmDeclaration>();
    this.attributes = _hashMap_1;
    HashMap<String, Relation> _hashMap_2 = new HashMap<String, Relation>();
    this.relations = _hashMap_2;
  }
  
  /**
   * Method to obtain a sequence of characters containing the constraint
   * representation of the model regarding the type of the problem and the
   * notation.
   * @param model is an ECORE syntax tree with the program
   * this syntax tree should be traversed.
   */
  @Override
  public CharSequence parseModel(final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("% Autogenerated code form the Coffee framework");
    _builder.newLine();
    _builder.append("% Author: avillota");
    _builder.newLine();
    _builder.append("% Variables from elements definitions ");
    _builder.newLine();
    CharSequence _parseElements = this.parseElements(model);
    _builder.append(_parseElements);
    _builder.newLineIfNotEmpty();
    _builder.append("% Variables and constraints from the variability relations definition");
    _builder.newLine();
    CharSequence _parseRelations = this.parseRelations(model);
    _builder.append(_parseRelations);
    _builder.newLineIfNotEmpty();
    _builder.append("% The solving parameters from the parameters files");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * This method traverses the list of variables to parse each declaration
   * The declaration is made by the factory
   * @param model
   */
  @Override
  public CharSequence parseElements(final Model model) {
    String _xblockexpression = null;
    {
      String out = "";
      EList<ElmDeclaration> _elements = model.getElements();
      for (final ElmDeclaration element : _elements) {
        if (((element.getAtt() != null) && Objects.equal(element.getAtt(), "att"))) {
          this.attributes.put(element.getName(), element);
        } else {
          Declaration _declaration = element.getDeclaration();
          if ((_declaration instanceof ConstantDecl)) {
            Declaration _declaration_1 = element.getDeclaration();
            final Value value = ((ConstantDecl) _declaration_1).getValue();
            if ((Objects.equal(element.getDataType(), "boolean") && (value == null))) {
              String _out = out;
              CharSequence _element = this.factory.getElement(element);
              out = (_out + _element);
            } else {
              String _out_1 = out;
              CharSequence _constant = this.factory.getConstant(element);
              out = (_out_1 + _constant);
            }
          } else {
            Declaration _declaration_2 = element.getDeclaration();
            if ((_declaration_2 instanceof VariableDecl)) {
              String _out_2 = out;
              CharSequence _element_1 = this.factory.getElement(element);
              out = (_out_2 + _element_1);
            }
          }
        }
      }
      _xblockexpression = out;
    }
    return _xblockexpression;
  }
  
  /**
   * Method to parse the constraints in a model.
   * The constraints are contained in a collection
   * of constraints
   * @param model
   */
  @Override
  public CharSequence parseRelations(final Model model) {
    String _xblockexpression = null;
    {
      String out = "";
      EList<RelDeclaration> _relations = model.getRelations();
      for (final RelDeclaration e : _relations) {
        {
          this.relations.put(e.getName(), e.getExp());
          String _out = out;
          CharSequence _parseRelation = this.parseRelation(e.getExp());
          out = (_out + _parseRelation);
        }
      }
      _xblockexpression = out;
    }
    return _xblockexpression;
  }
  
  /**
   * This method is used to determine he type of an expression and
   * call the method in charge to produce the code.
   * @param exp is a constraint expression
   */
  @Override
  public CharSequence parseRelation(final Relation rel) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (rel instanceof Core) {
      _matched=true;
      _switchResult = this.factory.getCore(((Core)rel));
    }
    if (!_matched) {
      if (rel instanceof Decomposition) {
        _matched=true;
        _switchResult = this.factory.getDecomposition(((Decomposition)rel), this.parents);
      }
    }
    if (!_matched) {
      if (rel instanceof Group) {
        _matched=true;
        _switchResult = this.factory.getGroup(((Group)rel), this.parents);
      }
    }
    if (!_matched) {
      if (rel instanceof Pair) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          final Pair pair = ((Pair) rel);
          CharSequence _xifexpression = null;
          String _operator = pair.getOperator();
          boolean _equals = Objects.equal(_operator, "implies");
          if (_equals) {
            _xifexpression = this.factory.getImpliesPair(((Pair)rel).getVar1(), ((Pair)rel).getVar2());
          } else {
            _xifexpression = this.factory.getMutexPair(((Pair)rel).getVar1(), ((Pair)rel).getVar2());
          }
          _xblockexpression = _xifexpression;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof VarList) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          final VarList pair = ((VarList) rel);
          CharSequence _xifexpression = null;
          String _operator = pair.getOperator();
          boolean _equals = Objects.equal(_operator, "implies");
          if (_equals) {
            _xifexpression = this.factory.getImpliesList(((VarList)rel));
          } else {
            _xifexpression = this.factory.getMutexList(((VarList)rel));
          }
          _xblockexpression = _xifexpression;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof Expression) {
        _matched=true;
        _switchResult = this.factory.getExpression(((Expression)rel).getExp());
      }
    }
    if (!_matched) {
      if (rel instanceof Visibility) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          ArrayList<CharSequence> relations = new ArrayList<CharSequence>();
          EList<RelDeclaration> _ids = ((Visibility)rel).getChildren().getIds();
          for (final RelDeclaration r : _ids) {
            relations.add(this.parseRelation(r.getExp()));
          }
          _xblockexpression = this.factory.getVisibility(((Visibility)rel), relations);
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof MultInstantiation) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (rel instanceof QImplies) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (rel instanceof ComplexImplies) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    return _switchResult;
  }
  
  /**
   * ===================================================================
   * ===================================================================
   *  Getters and setters
   */
  @Override
  public String getModelName() {
    return this.modelName;
  }
  
  @Override
  public Dialect getDialect() {
    return this.dialect;
  }
  
  @Override
  public void addParents(final Decomposition exp) {
    EList<ElmDeclaration> _values = exp.getChildren().getValues();
    for (final ElmDeclaration element : _values) {
      this.parents.put(element.getName(), exp.getParent());
    }
  }
  
  @Override
  public Map<String, ElmDeclaration> getParents() {
    return this.parents;
  }
  
  @Override
  public void setFactory(final CodeFactory factory) {
    this.factory = factory;
  }
}

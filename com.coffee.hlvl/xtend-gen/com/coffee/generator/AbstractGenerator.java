package com.coffee.generator;

import com.coffee.generator.CodeFactory;
import com.coffee.generator.Dialect;
import com.coffee.generator.IGenerator;
import com.coffee.hlvl.BoolVal;
import com.coffee.hlvl.ComplexImplies;
import com.coffee.hlvl.ConstantDecl;
import com.coffee.hlvl.Core;
import com.coffee.hlvl.Declaration;
import com.coffee.hlvl.Decomposition;
import com.coffee.hlvl.ElmDeclaration;
import com.coffee.hlvl.Expression;
import com.coffee.hlvl.Group;
import com.coffee.hlvl.Model;
import com.coffee.hlvl.MultInstantiation;
import com.coffee.hlvl.Operation;
import com.coffee.hlvl.Operations;
import com.coffee.hlvl.Pair;
import com.coffee.hlvl.QImplies;
import com.coffee.hlvl.RelDeclaration;
import com.coffee.hlvl.Relation;
import com.coffee.hlvl.SingleInstruction;
import com.coffee.hlvl.Symbol;
import com.coffee.hlvl.ValidConf;
import com.coffee.hlvl.Valuation;
import com.coffee.hlvl.Value;
import com.coffee.hlvl.VarList;
import com.coffee.hlvl.VariableDecl;
import com.coffee.hlvl.Visibility;
import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtend2.lib.StringConcatenation;

/**
 * Abstract Generator, this is the class that process the model and traverses the
 * syntax tree regardless the type of notation and problem
 * @author Angela Villota
 * @version HLVL 1
 * August 2018
 * adpated to the HLVl grammar on January 2019
 */
@SuppressWarnings("all")
public abstract class AbstractGenerator implements IGenerator {
  /**
   * Name of the PL model
   */
  private String modelName;
  
  private Dialect dialect;
  
  /**
   * object to obtain the program sentences regarding the type of the problem
   */
  private CodeFactory factory;
  
  /**
   * Map with the parent of each variable, for decomposition relations
   */
  private Map<String, ElmDeclaration> parents;
  
  /**
   * Map with the parent of each variable, for decomposition relations
   */
  private Map<String, Relation> relations;
  
  private Map<String, ElmDeclaration> attributes;
  
  private String properties;
  
  /**
   * Constructor method
   * @param the name of the model
   * @param type of the problem
   */
  public AbstractGenerator(final String name, final Dialect dialect) {
    this.modelName = name;
    this.dialect = dialect;
    HashMap<String, ElmDeclaration> _hashMap = new HashMap<String, ElmDeclaration>();
    this.parents = _hashMap;
    HashMap<String, ElmDeclaration> _hashMap_1 = new HashMap<String, ElmDeclaration>();
    this.attributes = _hashMap_1;
    HashMap<String, Relation> _hashMap_2 = new HashMap<String, Relation>();
    this.relations = _hashMap_2;
    this.properties = "";
  }
  
  /**
   * Method to obtain a sequence of characters containing the constraint
   * representation of the model regarding the type of the problem and the
   * notation.
   * @param model is an ECORE syntax tree with the program
   * this syntax tree should be traversed.
   */
  @Override
  public CharSequence parseModel(final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("% Autogenerated code form the Coffee framework");
    _builder.newLine();
    _builder.append("% Author: avillota");
    _builder.newLine();
    _builder.append("% Variables from elements definitions ");
    _builder.newLine();
    CharSequence _parseElements = this.parseElements(model);
    _builder.append(_parseElements);
    _builder.newLineIfNotEmpty();
    _builder.append("% Variables and constraints from the variability relations definition");
    _builder.newLine();
    CharSequence _parseRelations = this.parseRelations(model);
    _builder.append(_parseRelations);
    _builder.newLineIfNotEmpty();
    _builder.append("% The solving parameters from the parameters files");
    _builder.newLine();
    CharSequence _parseOperations = this.parseOperations(model);
    _builder.append(_parseOperations);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  /**
   * This method traverses the list of variables to parse each declaration
   * The declaration is made by the factory
   * @param model
   */
  @Override
  public CharSequence parseElements(final Model model) {
    String _xblockexpression = null;
    {
      String out = "";
      EList<ElmDeclaration> _elements = model.getElements();
      for (final ElmDeclaration element : _elements) {
        if (((element.getAtt() != null) && Objects.equal(element.getAtt(), "att"))) {
          this.attributes.put(element.getName(), element);
        } else {
          Declaration _declaration = element.getDeclaration();
          if ((_declaration instanceof ConstantDecl)) {
            Declaration _declaration_1 = element.getDeclaration();
            final Value value = ((ConstantDecl) _declaration_1).getValue();
            if ((Objects.equal(element.getDataType(), "boolean") && (value == null))) {
              String _out = out;
              CharSequence _element = this.factory.getElement(element);
              out = (_out + _element);
            } else {
              String _out_1 = out;
              CharSequence _constant = this.factory.getConstant(element);
              out = (_out_1 + _constant);
            }
          } else {
            Declaration _declaration_2 = element.getDeclaration();
            if ((_declaration_2 instanceof VariableDecl)) {
              String _out_2 = out;
              CharSequence _element_1 = this.factory.getElement(element);
              out = (_out_2 + _element_1);
            }
          }
        }
      }
      _xblockexpression = out;
    }
    return _xblockexpression;
  }
  
  /**
   * Method to parse the constraints in a model.
   * The constraints are contained in a collection
   * of constraints
   * @param model
   */
  @Override
  public CharSequence parseRelations(final Model model) {
    String _xblockexpression = null;
    {
      String out = "";
      EList<RelDeclaration> _relations = model.getRelations();
      for (final RelDeclaration e : _relations) {
        {
          this.relations.put(e.getName(), e.getExp());
          String _out = out;
          CharSequence _parseRelation = this.parseRelation(e.getExp());
          out = (_out + _parseRelation);
        }
      }
      _xblockexpression = out;
    }
    return _xblockexpression;
  }
  
  /**
   * This method is used to determine he type of an expression and
   * call the method in charge to produce the code.
   * @param exp is a constraint expression
   */
  @Override
  public CharSequence parseRelation(final Relation rel) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (rel instanceof Core) {
      _matched=true;
      _switchResult = this.factory.getCore(((Core)rel));
    }
    if (!_matched) {
      if (rel instanceof Decomposition) {
        _matched=true;
        _switchResult = this.factory.getDecomposition(((Decomposition)rel), this.parents);
      }
    }
    if (!_matched) {
      if (rel instanceof Group) {
        _matched=true;
        _switchResult = this.factory.getGroup(((Group)rel), this.parents);
      }
    }
    if (!_matched) {
      if (rel instanceof Pair) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          final Pair pair = ((Pair) rel);
          CharSequence _xifexpression = null;
          String _operator = pair.getOperator();
          boolean _equals = Objects.equal(_operator, "implies");
          if (_equals) {
            _xifexpression = this.factory.getImpliesPair(((Pair)rel).getVar1(), ((Pair)rel).getVar2());
          } else {
            _xifexpression = this.factory.getMutexPair(((Pair)rel).getVar1(), ((Pair)rel).getVar2());
          }
          _xblockexpression = _xifexpression;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof VarList) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          final VarList pair = ((VarList) rel);
          CharSequence _xifexpression = null;
          String _operator = pair.getOperator();
          boolean _equals = Objects.equal(_operator, "implies");
          if (_equals) {
            _xifexpression = this.factory.getImpliesList(((VarList)rel));
          } else {
            _xifexpression = this.factory.getMutexList(((VarList)rel));
          }
          _xblockexpression = _xifexpression;
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof Expression) {
        _matched=true;
        _switchResult = this.factory.getExpression(((Expression)rel).getExp());
      }
    }
    if (!_matched) {
      if (rel instanceof Visibility) {
        _matched=true;
        CharSequence _xblockexpression = null;
        {
          ArrayList<CharSequence> relations = new ArrayList<CharSequence>();
          EList<RelDeclaration> _ids = ((Visibility)rel).getChildren().getIds();
          for (final RelDeclaration r : _ids) {
            relations.add(this.parseRelation(r.getExp()));
          }
          _xblockexpression = this.factory.getVisibility(((Visibility)rel), relations);
        }
        _switchResult = _xblockexpression;
      }
    }
    if (!_matched) {
      if (rel instanceof MultInstantiation) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (rel instanceof QImplies) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (rel instanceof ComplexImplies) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("n.y.i");
        _switchResult = _builder;
      }
    }
    return _switchResult;
  }
  
  public CharSequence parseOperations(final Model model) {
    CharSequence _xblockexpression = null;
    {
      String _properties = this.properties;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("{");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("\"problem\" : ");
      String _string = this.dialect.toString();
      _builder.append(_string, " ");
      _builder.append(",");
      _builder.newLineIfNotEmpty();
      this.properties = (_properties + _builder);
      String single = "";
      String notSingle = "";
      Operations _operations = model.getOperations();
      boolean _tripleEquals = (_operations == null);
      boolean _not = (!_tripleEquals);
      if (_not) {
        EList<Operation> _op = model.getOperations().getOp();
        for (final Operation oper : _op) {
          boolean _matched = false;
          if (oper instanceof SingleInstruction) {
            _matched=true;
            String _single = single;
            String _name = ((SingleInstruction)oper).getName();
            String _plus = (_name + ",");
            single = (_single + _plus);
          }
          if (!_matched) {
            if (oper instanceof ValidConf) {
              _matched=true;
              EList<Valuation> _pairs = ((ValidConf)oper).getValuations().getPairs();
              for (final Valuation valuation : _pairs) {
                {
                  String value = "";
                  Value _value = valuation.getValue();
                  boolean _matched_1 = false;
                  if (_value instanceof com.coffee.hlvl.Number) {
                    _matched_1=true;
                    Value _value_1 = valuation.getValue();
                    int _value_2 = ((com.coffee.hlvl.Number) _value_1).getValue();
                    String _plus = (Integer.valueOf(_value_2) + "");
                    value = _plus;
                  }
                  if (!_matched_1) {
                    if (_value instanceof BoolVal) {
                      _matched_1=true;
                      Value _value_1 = valuation.getValue();
                      value = ((BoolVal) _value_1).getValue();
                    }
                  }
                  if (!_matched_1) {
                    if (_value instanceof Symbol) {
                      _matched_1=true;
                      Value _value_1 = valuation.getValue();
                      value = ((Symbol) _value_1).getValue();
                    }
                  }
                  String _notSingle = notSingle;
                  StringConcatenation _builder_1 = new StringConcatenation();
                  _builder_1.append("{");
                  _builder_1.newLine();
                  _builder_1.append("\t");
                  _builder_1.append("\"element\" : \"");
                  String _name = valuation.getElement().getName();
                  _builder_1.append(_name, "\t");
                  _builder_1.append("\",");
                  _builder_1.newLineIfNotEmpty();
                  _builder_1.append("\t");
                  _builder_1.append("\"value\" : \"");
                  _builder_1.append(value, "\t");
                  _builder_1.append("\"");
                  _builder_1.newLineIfNotEmpty();
                  _builder_1.append("},");
                  _builder_1.newLine();
                  notSingle = (_notSingle + _builder_1);
                }
              }
            }
          }
        }
        int _length = single.length();
        int _minus = (_length - 1);
        single = single.substring(0, _minus);
      }
      String _properties_1 = this.properties;
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("\"operationSingle\" : [");
      _builder_1.append(single);
      _builder_1.append("],");
      _builder_1.newLineIfNotEmpty();
      _builder_1.append("\"validConfiguration\" :[");
      _builder_1.append(notSingle);
      _builder_1.append("]");
      _builder_1.newLineIfNotEmpty();
      _builder_1.append("}");
      _builder_1.newLine();
      this.properties = (_properties_1 + _builder_1);
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append(" ");
      _xblockexpression = _builder_2;
    }
    return _xblockexpression;
  }
  
  /**
   * ===================================================================
   * ===================================================================
   *  Getters and setters
   */
  @Override
  public String getModelName() {
    return this.modelName;
  }
  
  @Override
  public Dialect getDialect() {
    return this.dialect;
  }
  
  @Override
  public void addParents(final Decomposition exp) {
    EList<ElmDeclaration> _values = exp.getChildren().getValues();
    for (final ElmDeclaration element : _values) {
      this.parents.put(element.getName(), exp.getParent());
    }
  }
  
  @Override
  public Map<String, ElmDeclaration> getParents() {
    return this.parents;
  }
  
  @Override
  public void setFactory(final CodeFactory factory) {
    this.factory = factory;
  }
  
  @Override
  public String getProperties() {
    return this.properties;
  }
}

/*
 * generated by Xtext 2.12.0
 */
package com.coffee.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.coffee.hlvl.Model
import com.coffee.hlvl.MultInstantiation
import com.coffee.hlvl.Group
import com.coffee.generator.bools.BoolGenerator
import com.coffee.generator.Integers.IntGenerator
import java.util.Properties

/**
 *  Class autogenerated by xtext and edited to define the code generator
 * for the High Level Variability Language (HLVL)
 * @author Angela Villota
 * @version HLVL 1
 * August 201
 * Updated on January 2019 to the new HLVL grammar
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HlvlGenerator extends AbstractGenerator {
	private boolean instantiable =false;
	private boolean attributes= false;
	private Properties operations= new Properties();
	private IGenerator generator;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
// obtaining the name of the model from the source code
		val modelName= modelName(resource.contents.head as Model)
		// obtaining the model
		val model= resource.contents.head as Model
		
		//obtaining the type of problem
		val dialect= setDialect(model)
		
		val long startTime = System.currentTimeMillis();
		
		
		// Determining the type of the problem to produce the solver compatible 
		if(dialect==Dialect.BOOL){
			//generating an intermediate file with the textual Dimacs representation
			fsa.generateFile(modelName+"_bool.mzn", toBoolean(model, modelName, fsa))
		}
		else{
			//generating an intermediate file with the xml XCSP3 representation
			fsa.generateFile(modelName+"_int.mzn", toInteger(model, modelName, dialect))
		}
		fsa.generateFile(modelName+"_Operations.json", generator.getProperties)
		val long stopTime = System.currentTimeMillis();
    	val long elapsedTime = stopTime - startTime;
        System.out.println("time of the transformation "+ elapsedTime +"ms");
	}
	/**
	 * Method to obtain the name of the model
	 * @param modes is of type Model 
	 * @returns String name with the name of the model
	 */
	def modelName(Model model) {
		var name = model.name.toFirstUpper
		return name
	}
	
	/**
	 * Method that determines the dialect used to specify the model
	 * using the  
	 * @param model is an abstract representation of the model
	 */
	def Dialect setDialect(Model model){
		/*
		 * A problem is basic iff it has boolean:
		 * 1. All elements of type boolean
		 * 2. All attributes boolean attributes
		 * 3. decompositions between boolean elements only
		 * 4. groups with cardinality: 1, 1, 1,*
		 * 5. boolean expressions
		 * 
		 * A problem is of type INST iff
		 * 1. it contains the instantiation operator
		 * 
		 * else if an att
		 */
		
		if (allBoolean(model) 
			&& booleanRelations(model)){
			return Dialect.BOOL
		}else if(existInstantiable()){
			return Dialect.INST
		}else{
			return Dialect.ATT
		}
	}
	
	/**
	 * Method to determine the type of the variables 
	 * If there are one variable that cannot be mapped into a boolean
	 * variable, then the method returns CSP. 
	 * @param model
	 * @return true if all elements are booleans
	 */
	def allBoolean(Model model){
		var isBoolean= true
		for (element: model.elements ){
			attributes = !(element.att=== null)
			//isBoolean = isBoolean && (element.dataType=="boolean")
			if (element.dataType=="integer"){
				isBoolean= false
				return isBoolean
			}
		}
		return isBoolean
	}
	
	/**
	 * Method to determine the type of the constraints 
	 * If there are one constraint that cannot be mapped into a boolean
	 * constraint, then the method returns false. 
	 * @param model
	 * @return true if all constraints can be mapped to boolean
	 */
	def booleanRelations(Model model){
		var allBoolean =true

		for (rel: model.relations ){
			// if a relation is of type multi-instantions, 
			// the problem cannot be boolean
			if (rel.exp instanceof MultInstantiation){
				instantiable =true
				return false
			} else if(rel.exp instanceof Group){
				
				val min = (rel.exp as Group).min
				val numChildren= (rel.exp as Group).getChildren.values.size
				var int max
				if ((rel.exp as Group).max.value == "*"){
					max=numChildren
				}
				else{
					max=  Integer.parseInt(
					(rel.exp as Group).max.value)
				}
				
				if ( !(min==1 && max == 1) &&  //[1,1] 
					!(min==1 && (max==numChildren)) //&& //[1..n] 
					//!(min==1 && (max==numChildren)) //[1..*]
					) {
					//( !(min==1 && max == 1) && !(min==1 && (max==numChildren)) && !(min==1 && (wildCard>-1)))
					return false
				}
			}
		}
		// if the loop is finished, then the model has all boolean relations
		return allBoolean
	}
	
	def existInstantiable(){
		return instantiable
	}
	
	def toBoolean(Model model, String modelName, IFileSystemAccess2 fsa) {
		//en este metodo se debe  instanciar el generador de XCSP3 
		//se les manda como parámetro el tipo de problema. 
		generator= new BoolGenerator(modelName)
		generator.parseModel(model)
	}
	
	def toInteger(Model model, String modelName,Dialect dialect) {
		//en este metodo se debe  instanciar el generador de XCSP3 
		//se les manda como parámetro el tipo de problema. 
//		var DIMACSGenerator dimacs= new DIMACSGenerator(modelName, typeOfProblem)
//		dimacs.parseModel(model)
		generator= new IntGenerator(modelName, dialect)
		generator.parseModel(model)
		
	}
	
	def PropertieswriteOperationsFile(Dialect dialect){
		
		
	}
	 
	
}

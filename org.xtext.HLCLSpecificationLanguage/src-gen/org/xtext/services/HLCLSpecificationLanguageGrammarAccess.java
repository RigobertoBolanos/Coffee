/*
 * generated by Xtext 2.12.0
 */
package org.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class HLCLSpecificationLanguageGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cVariablesKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVarsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarsVarDeclarationParserRuleCall_3_0 = (RuleCall)cVarsAssignment_3.eContents().get(0);
		private final Keyword cConstraintsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cConstraintsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cConstraintsConstraintParserRuleCall_5_0 = (RuleCall)cConstraintsAssignment_5.eContents().get(0);
		
		//Model:
		//	'model' name=ID 'variables:' vars+=VarDeclaration+ 'constraints:' constraints+=Constraint+;
		@Override public ParserRule getRule() { return rule; }
		
		//'model' name=ID 'variables:' vars+=VarDeclaration+ 'constraints:' constraints+=Constraint+
		public Group getGroup() { return cGroup; }
		
		//'model'
		public Keyword getModelKeyword_0() { return cModelKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'variables:'
		public Keyword getVariablesKeyword_2() { return cVariablesKeyword_2; }
		
		//vars+=VarDeclaration+
		public Assignment getVarsAssignment_3() { return cVarsAssignment_3; }
		
		//VarDeclaration
		public RuleCall getVarsVarDeclarationParserRuleCall_3_0() { return cVarsVarDeclarationParserRuleCall_3_0; }
		
		//'constraints:'
		public Keyword getConstraintsKeyword_4() { return cConstraintsKeyword_4; }
		
		//constraints+=Constraint+
		public Assignment getConstraintsAssignment_5() { return cConstraintsAssignment_5; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_5_0() { return cConstraintsConstraintParserRuleCall_5_0; }
	}
	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModifierParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cVariantsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDomAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDomVariantDeclarationParserRuleCall_3_0 = (RuleCall)cDomAssignment_3.eContents().get(0);
		
		//VarDeclaration:
		//	Modifier name=ID 'variants:' dom=VariantDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//Modifier name=ID 'variants:' dom=VariantDeclaration
		public Group getGroup() { return cGroup; }
		
		//Modifier
		public RuleCall getModifierParserRuleCall_0() { return cModifierParserRuleCall_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'variants:'
		public Keyword getVariantsKeyword_2() { return cVariantsKeyword_2; }
		
		//dom=VariantDeclaration
		public Assignment getDomAssignment_3() { return cDomAssignment_3; }
		
		//VariantDeclaration
		public RuleCall getDomVariantDeclarationParserRuleCall_3_0() { return cDomVariantDeclarationParserRuleCall_3_0; }
	}
	public class ModifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.Modifier");
		private final UnorderedGroup cUnorderedGroup = (UnorderedGroup)rule.eContents().get(1);
		private final Assignment cInstantiableAssignment_0 = (Assignment)cUnorderedGroup.eContents().get(0);
		private final Keyword cInstantiableInstantiableKeyword_0_0 = (Keyword)cInstantiableAssignment_0.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cUnorderedGroup.eContents().get(1);
		private final RuleCall cTypeVarTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		
		//Modifier:
		//	instantiable?='instantiable'? & type=VarType;
		@Override public ParserRule getRule() { return rule; }
		
		//instantiable?='instantiable'? & type=VarType
		public UnorderedGroup getUnorderedGroup() { return cUnorderedGroup; }
		
		//instantiable?='instantiable'?
		public Assignment getInstantiableAssignment_0() { return cInstantiableAssignment_0; }
		
		//'instantiable'
		public Keyword getInstantiableInstantiableKeyword_0_0() { return cInstantiableInstantiableKeyword_0_0; }
		
		//type=VarType
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//VarType
		public RuleCall getTypeVarTypeParserRuleCall_1_0() { return cTypeVarTypeParserRuleCall_1_0; }
	}
	public class VariantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.VariantDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariantsIntervalParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariantsEnumerationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//VariantDeclaration:
		//	variantsInterval | variantsEnumeration //| variantsSet son los conjuntos de variables
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//variantsInterval | variantsEnumeration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//variantsInterval
		public RuleCall getVariantsIntervalParserRuleCall_0() { return cVariantsIntervalParserRuleCall_0; }
		
		//variantsEnumeration
		public RuleCall getVariantsEnumerationParserRuleCall_1() { return cVariantsEnumerationParserRuleCall_1; }
	}
	public class VariantsIntervalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.variantsInterval");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariantsIntervalAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cStartAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStartValueParserRuleCall_1_0 = (RuleCall)cStartAssignment_1.eContents().get(0);
		private final Keyword cColonColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cEndAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEndValueParserRuleCall_3_0 = (RuleCall)cEndAssignment_3.eContents().get(0);
		
		//variantsInterval:
		//	{variantsInterval} start=Value '::' end=Value;
		@Override public ParserRule getRule() { return rule; }
		
		//{variantsInterval} start=Value '::' end=Value
		public Group getGroup() { return cGroup; }
		
		//{variantsInterval}
		public Action getVariantsIntervalAction_0() { return cVariantsIntervalAction_0; }
		
		//start=Value
		public Assignment getStartAssignment_1() { return cStartAssignment_1; }
		
		//Value
		public RuleCall getStartValueParserRuleCall_1_0() { return cStartValueParserRuleCall_1_0; }
		
		//'::'
		public Keyword getColonColonKeyword_2() { return cColonColonKeyword_2; }
		
		//end=Value
		public Assignment getEndAssignment_3() { return cEndAssignment_3; }
		
		//Value
		public RuleCall getEndValueParserRuleCall_3_0() { return cEndValueParserRuleCall_3_0; }
	}
	public class VariantsEnumerationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.variantsEnumeration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariantsEnumerationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListEnumerationParserRuleCall_2_0 = (RuleCall)cListAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//variantsEnumeration:
		//	{variantsEnumeration} '[' list+=Enumeration ']';
		@Override public ParserRule getRule() { return rule; }
		
		//{variantsEnumeration} '[' list+=Enumeration ']'
		public Group getGroup() { return cGroup; }
		
		//{variantsEnumeration}
		public Action getVariantsEnumerationAction_0() { return cVariantsEnumerationAction_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//list+=Enumeration
		public Assignment getListAssignment_2() { return cListAssignment_2; }
		
		//Enumeration
		public RuleCall getListEnumerationParserRuleCall_2_0() { return cListEnumerationParserRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class EnumerationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.Enumeration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cListOfValuesParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cListOfIDsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Enumeration:
		//	ListOfValues | ListOfIDs;
		@Override public ParserRule getRule() { return rule; }
		
		//ListOfValues | ListOfIDs
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ListOfValues
		public RuleCall getListOfValuesParserRuleCall_0() { return cListOfValuesParserRuleCall_0; }
		
		//ListOfIDs
		public RuleCall getListOfIDsParserRuleCall_1() { return cListOfIDsParserRuleCall_1; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpConsExpressionParserRuleCall_2_0 = (RuleCall)cExpAssignment_2.eContents().get(0);
		
		////variantsSet:
		////		 vars=('(') list +=  ListOfIDs  (')') 
		////	values?=  '[' '('   ListOfValues ')' (',' '(' ListOfValues')')+ ']'
		////;
		//Constraint:
		//	name=ID ':' exp=ConsExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' exp=ConsExpression
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//exp=ConsExpression
		public Assignment getExpAssignment_2() { return cExpAssignment_2; }
		
		//ConsExpression
		public RuleCall getExpConsExpressionParserRuleCall_2_0() { return cExpConsExpressionParserRuleCall_2_0; }
	}
	public class ConsExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.ConsExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDConsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRefinementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRuleParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSPLNotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ConsExpression:
		//	IDCons | Refinement | Rule | SPLNotation;
		@Override public ParserRule getRule() { return rule; }
		
		//IDCons | Refinement | Rule | SPLNotation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IDCons
		public RuleCall getIDConsParserRuleCall_0() { return cIDConsParserRuleCall_0; }
		
		//Refinement
		public RuleCall getRefinementParserRuleCall_1() { return cRefinementParserRuleCall_1; }
		
		//Rule
		public RuleCall getRuleParserRuleCall_2() { return cRuleParserRuleCall_2; }
		
		//SPLNotation
		public RuleCall getSPLNotationParserRuleCall_3() { return cSPLNotationParserRuleCall_3; }
	}
	public class TerminalExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.TerminalExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cConsExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cIDConsParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TerminalExp Expression:
		//	'(' ConsExpression ')' | IDCons;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' ConsExpression ')' | IDCons
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' ConsExpression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//ConsExpression
		public RuleCall getConsExpressionParserRuleCall_0_1() { return cConsExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//IDCons
		public RuleCall getIDConsParserRuleCall_1() { return cIDConsParserRuleCall_1; }
	}
	public class IDConsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.IDCons");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//IDCons:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class RefinementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.Refinement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAssignmentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVarRefinementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSetRefinementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Refinement:
		//	Assignment | VarRefinement | SetRefinement;
		@Override public ParserRule getRule() { return rule; }
		
		//Assignment | VarRefinement | SetRefinement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall_0() { return cAssignmentParserRuleCall_0; }
		
		//VarRefinement
		public RuleCall getVarRefinementParserRuleCall_1() { return cVarRefinementParserRuleCall_1; }
		
		//SetRefinement
		public RuleCall getSetRefinementParserRuleCall_2() { return cSetRefinementParserRuleCall_2; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarIDTerminalRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cIsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Assignment:
		//	var=ID 'is' value=Value;
		@Override public ParserRule getRule() { return rule; }
		
		//var=ID 'is' value=Value
		public Group getGroup() { return cGroup; }
		
		//var=ID
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }
		
		//ID
		public RuleCall getVarIDTerminalRuleCall_0_0() { return cVarIDTerminalRuleCall_0_0; }
		
		//'is'
		public Keyword getIsKeyword_1() { return cIsKeyword_1; }
		
		//value=Value
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Value
		public RuleCall getValueValueParserRuleCall_2_0() { return cValueValueParserRuleCall_2_0; }
	}
	public class VarRefinementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.VarRefinement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarIDTerminalRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVariantsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVariantsVariantDeclarationParserRuleCall_2_0 = (RuleCall)cVariantsAssignment_2.eContents().get(0);
		
		//VarRefinement:
		//	var=ID 'in' variants=VariantDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//var=ID 'in' variants=VariantDeclaration
		public Group getGroup() { return cGroup; }
		
		//var=ID
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }
		
		//ID
		public RuleCall getVarIDTerminalRuleCall_0_0() { return cVarIDTerminalRuleCall_0_0; }
		
		//'in'
		public Keyword getInKeyword_1() { return cInKeyword_1; }
		
		//variants=VariantDeclaration
		public Assignment getVariantsAssignment_2() { return cVariantsAssignment_2; }
		
		//VariantDeclaration
		public RuleCall getVariantsVariantDeclarationParserRuleCall_2_0() { return cVariantsVariantDeclarationParserRuleCall_2_0; }
	}
	public class SetRefinementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.SetRefinement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVarsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarsListOfIDsParserRuleCall_1_0 = (RuleCall)cVarsAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cVariantsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cHeadAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cHeadListOfValuesParserRuleCall_6_0 = (RuleCall)cHeadAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cCommaKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Assignment cTailAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cTailListOfValuesParserRuleCall_8_2_0 = (RuleCall)cTailAssignment_8_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_8_3 = (Keyword)cGroup_8.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//SetRefinement:
		//	'(' vars=ListOfIDs ')'
		//	'variants'
		//	'[' '(' head=ListOfValues ')' (',' '(' tail+=ListOfValues ')')+ ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' vars=ListOfIDs ')' 'variants' '[' '(' head=ListOfValues ')' (',' '(' tail+=ListOfValues ')')+ ']'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//vars=ListOfIDs
		public Assignment getVarsAssignment_1() { return cVarsAssignment_1; }
		
		//ListOfIDs
		public RuleCall getVarsListOfIDsParserRuleCall_1_0() { return cVarsListOfIDsParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
		
		//'variants'
		public Keyword getVariantsKeyword_3() { return cVariantsKeyword_3; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_4() { return cLeftSquareBracketKeyword_4; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_5() { return cLeftParenthesisKeyword_5; }
		
		//head=ListOfValues
		public Assignment getHeadAssignment_6() { return cHeadAssignment_6; }
		
		//ListOfValues
		public RuleCall getHeadListOfValuesParserRuleCall_6_0() { return cHeadListOfValuesParserRuleCall_6_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
		
		//(',' '(' tail+=ListOfValues ')')+
		public Group getGroup_8() { return cGroup_8; }
		
		//','
		public Keyword getCommaKeyword_8_0() { return cCommaKeyword_8_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_8_1() { return cLeftParenthesisKeyword_8_1; }
		
		//tail+=ListOfValues
		public Assignment getTailAssignment_8_2() { return cTailAssignment_8_2; }
		
		//ListOfValues
		public RuleCall getTailListOfValuesParserRuleCall_8_2_0() { return cTailListOfValuesParserRuleCall_8_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_8_3() { return cRightParenthesisKeyword_8_3; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_9() { return cRightSquareBracketKeyword_9; }
	}
	public class RuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.Rule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConditionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConditionTerminalExpParserRuleCall_0_0 = (RuleCall)cConditionAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConsequenceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConsequenceTerminalExpParserRuleCall_2_0 = (RuleCall)cConsequenceAssignment_2.eContents().get(0);
		
		//Rule:
		//	condition=TerminalExp '-->' consequence=TerminalExp;
		@Override public ParserRule getRule() { return rule; }
		
		//condition=TerminalExp '-->' consequence=TerminalExp
		public Group getGroup() { return cGroup; }
		
		//condition=TerminalExp
		public Assignment getConditionAssignment_0() { return cConditionAssignment_0; }
		
		//TerminalExp
		public RuleCall getConditionTerminalExpParserRuleCall_0_0() { return cConditionTerminalExpParserRuleCall_0_0; }
		
		//'-->'
		public Keyword getHyphenMinusHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusHyphenMinusGreaterThanSignKeyword_1; }
		
		//consequence=TerminalExp
		public Assignment getConsequenceAssignment_2() { return cConsequenceAssignment_2; }
		
		//TerminalExp
		public RuleCall getConsequenceTerminalExpParserRuleCall_2_0() { return cConsequenceTerminalExpParserRuleCall_2_0; }
	}
	public class SPLNotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.SPLNotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVar1Assignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVar1IDTerminalRuleCall_0_0 = (RuleCall)cVar1Assignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpSPLopParserRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cVar2Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVar2IDTerminalRuleCall_2_0 = (RuleCall)cVar2Assignment_2.eContents().get(0);
		
		//SPLNotation:
		//	var1=ID op=SPLop var2=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//var1=ID op=SPLop var2=ID
		public Group getGroup() { return cGroup; }
		
		//var1=ID
		public Assignment getVar1Assignment_0() { return cVar1Assignment_0; }
		
		//ID
		public RuleCall getVar1IDTerminalRuleCall_0_0() { return cVar1IDTerminalRuleCall_0_0; }
		
		//op=SPLop
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }
		
		//SPLop
		public RuleCall getOpSPLopParserRuleCall_1_0() { return cOpSPLopParserRuleCall_1_0; }
		
		//var2=ID
		public Assignment getVar2Assignment_2() { return cVar2Assignment_2; }
		
		//ID
		public RuleCall getVar2IDTerminalRuleCall_2_0() { return cVar2IDTerminalRuleCall_2_0; }
	}
	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cSelectedKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cUnselectedKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		////Simple:
		////	UnaryConstraint |SubType
		////;
		////
		////
		////
		////SubType:
		////	vars= '(' ListOfIDs ')' 'subtypeOf' var=ID
		////;
		////
		////UnaryConstraint:
		////	var= ID 'is' op=UnaryOperator 
		////;
		////
		////UnaryOperator:
		////	'optional' |'mandatory'
		////;
		////BinConstraint:
		////	var1= TerminalExp op= BinOperator var2= TerminalExp
		////;
		////
		////BinOperator:
		////	'requires' |'excludes' |'->'
		////;
		////NaryConstraint:
		////	op=NaryOperator vars=('(') list +=  ListOfIDs  (')') 
		////	values?=  '[' '('   ListOfValues ')' (',' '(' ListOfValues')')+ ']'
		////;
		////
		////NaryOperator:
		////	'variants'
		////;
		////syntactic categories
		//Value:
		//	INT | 'selected' | 'unselected';
		@Override public ParserRule getRule() { return rule; }
		
		//INT | 'selected' | 'unselected'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'selected'
		public Keyword getSelectedKeyword_1() { return cSelectedKeyword_1; }
		
		//'unselected'
		public Keyword getUnselectedKeyword_2() { return cUnselectedKeyword_2; }
	}
	public class VarTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.VarType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBooleanKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cNumericKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//VarType:
		//	'boolean' | 'numeric';
		@Override public ParserRule getRule() { return rule; }
		
		//'boolean' | 'numeric'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'boolean'
		public Keyword getBooleanKeyword_0() { return cBooleanKeyword_0; }
		
		//'numeric'
		public Keyword getNumericKeyword_1() { return cNumericKeyword_1; }
	}
	public class ListOfValuesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.ListOfValues");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cValueParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cValueParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//ListOfValues:
		//	Value (',' Value)+;
		@Override public ParserRule getRule() { return rule; }
		
		//Value (',' Value)+
		public Group getGroup() { return cGroup; }
		
		//Value
		public RuleCall getValueParserRuleCall_0() { return cValueParserRuleCall_0; }
		
		//(',' Value)+
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//Value
		public RuleCall getValueParserRuleCall_1_1() { return cValueParserRuleCall_1_1; }
	}
	public class ListOfIDsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.ListOfIDs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//ListOfIDs:
		//	ID (',' ID)+;
		@Override public ParserRule getRule() { return rule; }
		
		//ID (',' ID)+
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//(',' ID)+
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class SPLopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.HLCLSpecificationLanguage.SPLop");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cOptionalKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMandatoryKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRequiresKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cExcludesKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//SPLop:
		//	'optional' | 'mandatory' | 'requires' | 'excludes';
		@Override public ParserRule getRule() { return rule; }
		
		//'optional' | 'mandatory' | 'requires' | 'excludes'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'optional'
		public Keyword getOptionalKeyword_0() { return cOptionalKeyword_0; }
		
		//'mandatory'
		public Keyword getMandatoryKeyword_1() { return cMandatoryKeyword_1; }
		
		//'requires'
		public Keyword getRequiresKeyword_2() { return cRequiresKeyword_2; }
		
		//'excludes'
		public Keyword getExcludesKeyword_3() { return cExcludesKeyword_3; }
	}
	
	
	private final ModelElements pModel;
	private final VarDeclarationElements pVarDeclaration;
	private final ModifierElements pModifier;
	private final VariantDeclarationElements pVariantDeclaration;
	private final VariantsIntervalElements pVariantsInterval;
	private final VariantsEnumerationElements pVariantsEnumeration;
	private final EnumerationElements pEnumeration;
	private final ConstraintElements pConstraint;
	private final ConsExpressionElements pConsExpression;
	private final TerminalExpElements pTerminalExp;
	private final IDConsElements pIDCons;
	private final RefinementElements pRefinement;
	private final AssignmentElements pAssignment;
	private final VarRefinementElements pVarRefinement;
	private final SetRefinementElements pSetRefinement;
	private final RuleElements pRule;
	private final SPLNotationElements pSPLNotation;
	private final ValueElements pValue;
	private final VarTypeElements pVarType;
	private final ListOfValuesElements pListOfValues;
	private final ListOfIDsElements pListOfIDs;
	private final SPLopElements pSPLop;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public HLCLSpecificationLanguageGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pVarDeclaration = new VarDeclarationElements();
		this.pModifier = new ModifierElements();
		this.pVariantDeclaration = new VariantDeclarationElements();
		this.pVariantsInterval = new VariantsIntervalElements();
		this.pVariantsEnumeration = new VariantsEnumerationElements();
		this.pEnumeration = new EnumerationElements();
		this.pConstraint = new ConstraintElements();
		this.pConsExpression = new ConsExpressionElements();
		this.pTerminalExp = new TerminalExpElements();
		this.pIDCons = new IDConsElements();
		this.pRefinement = new RefinementElements();
		this.pAssignment = new AssignmentElements();
		this.pVarRefinement = new VarRefinementElements();
		this.pSetRefinement = new SetRefinementElements();
		this.pRule = new RuleElements();
		this.pSPLNotation = new SPLNotationElements();
		this.pValue = new ValueElements();
		this.pVarType = new VarTypeElements();
		this.pListOfValues = new ListOfValuesElements();
		this.pListOfIDs = new ListOfIDsElements();
		this.pSPLop = new SPLopElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.HLCLSpecificationLanguage".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	'model' name=ID 'variables:' vars+=VarDeclaration+ 'constraints:' constraints+=Constraint+;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//VarDeclaration:
	//	Modifier name=ID 'variants:' dom=VariantDeclaration;
	public VarDeclarationElements getVarDeclarationAccess() {
		return pVarDeclaration;
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}
	
	//Modifier:
	//	instantiable?='instantiable'? & type=VarType;
	public ModifierElements getModifierAccess() {
		return pModifier;
	}
	
	public ParserRule getModifierRule() {
		return getModifierAccess().getRule();
	}
	
	//VariantDeclaration:
	//	variantsInterval | variantsEnumeration //| variantsSet son los conjuntos de variables
	//;
	public VariantDeclarationElements getVariantDeclarationAccess() {
		return pVariantDeclaration;
	}
	
	public ParserRule getVariantDeclarationRule() {
		return getVariantDeclarationAccess().getRule();
	}
	
	//variantsInterval:
	//	{variantsInterval} start=Value '::' end=Value;
	public VariantsIntervalElements getVariantsIntervalAccess() {
		return pVariantsInterval;
	}
	
	public ParserRule getVariantsIntervalRule() {
		return getVariantsIntervalAccess().getRule();
	}
	
	//variantsEnumeration:
	//	{variantsEnumeration} '[' list+=Enumeration ']';
	public VariantsEnumerationElements getVariantsEnumerationAccess() {
		return pVariantsEnumeration;
	}
	
	public ParserRule getVariantsEnumerationRule() {
		return getVariantsEnumerationAccess().getRule();
	}
	
	//Enumeration:
	//	ListOfValues | ListOfIDs;
	public EnumerationElements getEnumerationAccess() {
		return pEnumeration;
	}
	
	public ParserRule getEnumerationRule() {
		return getEnumerationAccess().getRule();
	}
	
	////variantsSet:
	////		 vars=('(') list +=  ListOfIDs  (')') 
	////	values?=  '[' '('   ListOfValues ')' (',' '(' ListOfValues')')+ ']'
	////;
	//Constraint:
	//	name=ID ':' exp=ConsExpression;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//ConsExpression:
	//	IDCons | Refinement | Rule | SPLNotation;
	public ConsExpressionElements getConsExpressionAccess() {
		return pConsExpression;
	}
	
	public ParserRule getConsExpressionRule() {
		return getConsExpressionAccess().getRule();
	}
	
	//TerminalExp Expression:
	//	'(' ConsExpression ')' | IDCons;
	public TerminalExpElements getTerminalExpAccess() {
		return pTerminalExp;
	}
	
	public ParserRule getTerminalExpRule() {
		return getTerminalExpAccess().getRule();
	}
	
	//IDCons:
	//	name=ID;
	public IDConsElements getIDConsAccess() {
		return pIDCons;
	}
	
	public ParserRule getIDConsRule() {
		return getIDConsAccess().getRule();
	}
	
	//Refinement:
	//	Assignment | VarRefinement | SetRefinement;
	public RefinementElements getRefinementAccess() {
		return pRefinement;
	}
	
	public ParserRule getRefinementRule() {
		return getRefinementAccess().getRule();
	}
	
	//Assignment:
	//	var=ID 'is' value=Value;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//VarRefinement:
	//	var=ID 'in' variants=VariantDeclaration;
	public VarRefinementElements getVarRefinementAccess() {
		return pVarRefinement;
	}
	
	public ParserRule getVarRefinementRule() {
		return getVarRefinementAccess().getRule();
	}
	
	//SetRefinement:
	//	'(' vars=ListOfIDs ')'
	//	'variants'
	//	'[' '(' head=ListOfValues ')' (',' '(' tail+=ListOfValues ')')+ ']';
	public SetRefinementElements getSetRefinementAccess() {
		return pSetRefinement;
	}
	
	public ParserRule getSetRefinementRule() {
		return getSetRefinementAccess().getRule();
	}
	
	//Rule:
	//	condition=TerminalExp '-->' consequence=TerminalExp;
	public RuleElements getRuleAccess() {
		return pRule;
	}
	
	public ParserRule getRuleRule() {
		return getRuleAccess().getRule();
	}
	
	//SPLNotation:
	//	var1=ID op=SPLop var2=ID;
	public SPLNotationElements getSPLNotationAccess() {
		return pSPLNotation;
	}
	
	public ParserRule getSPLNotationRule() {
		return getSPLNotationAccess().getRule();
	}
	
	////Simple:
	////	UnaryConstraint |SubType
	////;
	////
	////
	////
	////SubType:
	////	vars= '(' ListOfIDs ')' 'subtypeOf' var=ID
	////;
	////
	////UnaryConstraint:
	////	var= ID 'is' op=UnaryOperator 
	////;
	////
	////UnaryOperator:
	////	'optional' |'mandatory'
	////;
	////BinConstraint:
	////	var1= TerminalExp op= BinOperator var2= TerminalExp
	////;
	////
	////BinOperator:
	////	'requires' |'excludes' |'->'
	////;
	////NaryConstraint:
	////	op=NaryOperator vars=('(') list +=  ListOfIDs  (')') 
	////	values?=  '[' '('   ListOfValues ')' (',' '(' ListOfValues')')+ ']'
	////;
	////
	////NaryOperator:
	////	'variants'
	////;
	////syntactic categories
	//Value:
	//	INT | 'selected' | 'unselected';
	public ValueElements getValueAccess() {
		return pValue;
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}
	
	//VarType:
	//	'boolean' | 'numeric';
	public VarTypeElements getVarTypeAccess() {
		return pVarType;
	}
	
	public ParserRule getVarTypeRule() {
		return getVarTypeAccess().getRule();
	}
	
	//ListOfValues:
	//	Value (',' Value)+;
	public ListOfValuesElements getListOfValuesAccess() {
		return pListOfValues;
	}
	
	public ParserRule getListOfValuesRule() {
		return getListOfValuesAccess().getRule();
	}
	
	//ListOfIDs:
	//	ID (',' ID)+;
	public ListOfIDsElements getListOfIDsAccess() {
		return pListOfIDs;
	}
	
	public ParserRule getListOfIDsRule() {
		return getListOfIDsAccess().getRule();
	}
	
	//SPLop:
	//	'optional' | 'mandatory' | 'requires' | 'excludes';
	public SPLopElements getSPLopAccess() {
		return pSPLop;
	}
	
	public ParserRule getSPLopRule() {
		return getSPLopAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

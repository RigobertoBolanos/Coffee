//Java imports
import java.util.HashMap;
import java.util.List;

//imports for hlcl 
import com.variamos.hlcl.core.HlclProgram; 
import com.variamos.hlcl.model.expressions.HlclFactory; 
import com.variamos.hlcl.model.domains.BinaryDomain;
import com.variamos.hlcl.model.domains.IntervalDomain;
import com.variamos.hlcl.model.domains.RangeDomain;
import com.variamos.hlcl.model.domains.StringDomain;
import com.variamos.hlcl.model.expressions.Identifier;
import com.variamos.hlcl.model.expressions.IntBooleanExpression;
import com.variamos.hlcl.model.expressions.NumericIdentifier;
import com.variamos.hlcl.model.expressions.SymbolicExpression;
import com.variamos.hlcl.model.expressions.IntNumericExpression;

//imports for solver
import com.variamos.solver.core.SWIPrologSolver;
import com.variamos.solver.core.compiler.Hlcl2SWIProlog;
import com.variamos.solver.model.SolverSolution;

/**
* This class is automatically generated from a product line model described in 
* constraint programming HLCL
* @author Angela Villota 
* @version CP-HLCL Version1
*
*/
public class Constraints { 				
	
	private String modelName;
	private HlclFactory factory;
	private HlclProgram hlclProgram;
	private SWIPrologSolver swiSolver;
	private String prologProgram;
	private HashMap<String,IntBooleanExpression> constraints;
	private HashMap<String,Identifier> variables;
	private HashMap<String,NumericIdentifier> numbers;
	/**
	* This is an autogenerated method* Constructor method
	* @param modelName is the name of the model in the  CP-HLCL specification
	*/
	public Constraints(String modelName){ 					
		
		this.modelName= modelName;
		hlclProgram= new HlclProgram();
		factory = new HlclFactory();
		variables= new HashMap<String,Identifier>();
		constraints= new HashMap<String,IntBooleanExpression>();
		numbers= new HashMap<String,NumericIdentifier>();
		NumericIdentifier one = factory.number(1);
		NumericIdentifier zero= factory.number(0);
		numbers.put("1", one);
		numbers.put("0", zero);
	} 				
	public static void main(String[] args) {
		Constraints obj = new Constraints("Constraints");
		obj.run();
	}
	public void run(){
		// first obtain a HlclProgram from the specification
		transformVars();
		transformConstraints(); 
		// use the solver to solve the constraint program
		evaluateSatisfiability();
		//show the output
		System.out.println(prologProgram);
	}
	public void transformVars() {
		//declaring the variable for the model
		Identifier ConstraintsVar = factory.newIdentifier("Constraints");
		BinaryDomain ConstraintsDom= new BinaryDomain();
		ConstraintsVar.setDomain(ConstraintsDom);	
		variables.put("ConstraintsVar", ConstraintsVar); //including the variable in the map
		//declaring variable A
		Identifier A = factory.newIdentifier("A");
		 				RangeDomain ADom= new RangeDomain(1, 5);
		A.setDomain(ADom);	
		variables.put("A", A); //including the variable in the map
		//declaring variable B
		Identifier B = factory.newIdentifier("B");
		 				RangeDomain BDom= new RangeDomain(1, 5);
		B.setDomain(BDom);	
		variables.put("B", B); //including the variable in the map
		//declaring variable D
		Identifier D = factory.newIdentifier("D");
		 					 						IntervalDomain DDom= new IntervalDomain(); 
				DDom.add(2); 								DDom.add(3); 								DDom.add(4); 						
		D.setDomain(DDom);	
		variables.put("D", D); //including the variable in the map
		//declaring variable E
		Identifier E = factory.newIdentifier("E");
		  			BinaryDomain EDom= new BinaryDomain();
		E.setDomain(EDom);	
		variables.put("E", E); //including the variable in the map
		//declaring variable C
		Identifier C = factory.newIdentifier("C");
		 					 						StringDomain CDom= new StringDomain();
				CDom.add("a"); 								CDom.add("b"); 								CDom.add("c"); 						
			C.setDomain(CDom);	
		variables.put("C", C); //including the variable in the map
		//declaring variable F
		Identifier F = factory.newIdentifier("F");
		 					 						StringDomain FDom= new StringDomain();
				FDom.add("e"); 								FDom.add("f"); 								FDom.add("g"); 						
			F.setDomain(FDom);	
		variables.put("F", F); //including the variable in the map
	}
	public void transformConstraints() {
		//declaring the constraint for the model
		IntBooleanExpression CConstraints= factory.equals(variables.get("ConstraintsVar"), getValue("1"));
		constraints.put("CConstraints", CConstraints);
		hlclProgram.add(CConstraints);
		//
		//declaring constraint C1
		SymbolicExpression C1= factory.newSymbolic("at_most", variables.get("A")
		, variables.get("C")
		);
		
		constraints.put("C1", C1);
		hlclProgram.add(C1);
		//
		//declaring constraint C2
		Identifier C2_left = variables.get("E");
		Identifier C2_right = variables.get("A");
		IntBooleanExpression C2=
		factory.and(C2_left, C2_right);
		constraints.put("C2", C2);
		hlclProgram.add(C2);
		//
		//declaring constraint C3
		Identifier C3_left_left = variables.get("E");
		Identifier C3_left_right = variables.get("A");
		IntBooleanExpression C3_left=
		factory.and(C3_left_left, C3_left_right);
		Identifier C3_right_left = variables.get("B");
		Identifier C3_right_right = variables.get("D");
		IntBooleanExpression C3_right=
		factory.and(C3_right_left, C3_right_right);
		IntBooleanExpression C3=
		factory.or(C3_left, C3_right);
		constraints.put("C3", C3);
		hlclProgram.add(C3);
		//
		//declaring constraint C4
		Identifier C4_left_left = variables.get("D");
		Identifier C4_left_right = variables.get("B");
		IntBooleanExpression C4_left=
		factory.and(C4_left_left, C4_left_right);
		Identifier C4_right = variables.get("F");
		IntBooleanExpression C4=
		factory.and(C4_left, C4_right);
		constraints.put("C4", C4);
		hlclProgram.add(C4);
		//
		//declaring constraint C5
		Identifier C5_left_left = variables.get("A");	
		Identifier C5_left_right = variables.get("B");	
		IntNumericExpression C5_left=
		factory.sum(C5_left_left, C5_left_right);
		IntBooleanExpression C5=
		factory.greaterThan(C5_left, C5_right);
		
		constraints.put("C5", C5);
		hlclProgram.add(C5);
	}
	public boolean evaluateSatisfiability(){
		// the output
		boolean evaluation= false;
		// //to transform the hllcl program into a prolog  file, 
		// //these lines are commented because they are useful for debugging 
		Hlcl2SWIProlog swiPrologTransformer = new Hlcl2SWIProlog(); 
		prologProgram = swiPrologTransformer.transform(hlclProgram);
				
		// an instance of the solver for Swiprolog 
		swiSolver= new SWIPrologSolver();
		swiSolver.setHLCLProgram(hlclProgram); //passing the hlcl program to the solver
		swiSolver.solve(); // This methhod prepares the solver 
		List<SolverSolution> solutions = swiSolver.getAllSolutions(); // Consulting if the solver has one solution
			evaluation= solutions.size()>0;
			for (SolverSolution solverSolution : solutions) {
				System.out.println(solverSolution.toString());
			}	return evaluation;
	}
	/** 
	* To obtain the NumericIdentifier representation of a value 
	* @param id the string with the value 
	* @return the NumericIdentifier 
	*/
	public NumericIdentifier getValue(String id) {	NumericIdentifier value= numbers.get(id); 
	 	if (value==null) { 
	 		if (id.equals("selected")) { 
	 			value= numbers.get("1"); 
	 		} 
	 		else if(id.equals("unselected")) {
				value= numbers.get("0"); 
			} 
			else { 
				value= factory.number(Integer.parseInt(id)); 
				numbers.put(id, value);
			}
	 	} 
	 	return value; 
	 } 
		public String getModelName() {
			return modelName;
		}
		public void setModelName(String modelName) {
			this.modelName = modelName;
		}
		public HlclFactory getFactory() {
			return factory;
		}
		public void setFactory(HlclFactory factory) {
			this.factory = factory;
		}
		public HlclProgram getHlclProgram() {
			return hlclProgram;
		}
		public void setHlclProgram(HlclProgram hlclProgram) {
			this.hlclProgram = hlclProgram;
		}
} 	
//Java imports
import java.util.HashMap;
import java.util.List;
//imports for hlcl 
import com.variamos.hlcl.core.HlclProgram; 
import com.variamos.hlcl.model.expressions.HlclFactory; 
import com.variamos.hlcl.model.domains.BinaryDomain;
import com.variamos.hlcl.model.domains.IntervalDomain;
import com.variamos.hlcl.model.domains.RangeDomain;
import com.variamos.hlcl.model.domains.StringDomain;
import com.variamos.hlcl.model.expressions.Identifier;
import com.variamos.hlcl.model.expressions.IntBooleanExpression;
import com.variamos.hlcl.model.expressions.NumericIdentifier;
import com.variamos.hlcl.model.expressions.SymbolicExpression;
import com.variamos.hlcl.model.expressions.IntNumericExpression;

//imports for solver
import com.variamos.solver.core.SWIPrologSolver;
import com.variamos.solver.core.compiler.Hlcl2SWIProlog;
import com.variamos.solver.model.SolverSolution;

/**
* This class is automatically generated from a product line model described in 
* constraint programming HLCL
* @author Angela Villota 
* @version CP-HLCL Version1
*
*/
public class Modelo1 { 			
	
	private String modelName;
	private HlclFactory factory;
	private HlclProgram hlclProgram;
	private SWIPrologSolver swiSolver;
	private String prologProgram;
	private HashMap<String,IntBooleanExpression> constraints;
	private HashMap<String,Identifier> variables;
	private HashMap<String,NumericIdentifier> numbers;
	/**
	* This is an autogenerated method* Constructor method
	* @param modelName is the name of the model in the  CP-HLCL specification
	*/
	public Modelo1(String modelName){ 				
		
		this.modelName= modelName;
		hlclProgram= new HlclProgram();
		factory = new HlclFactory();
		variables= new HashMap<String,Identifier>();
		constraints= new HashMap<String,IntBooleanExpression>();
		numbers= new HashMap<String,NumericIdentifier>();
		NumericIdentifier one = factory.number(1);
		NumericIdentifier zero= factory.number(0);
		numbers.put("1", one);
		numbers.put("0", zero);
	} 			
	public static void main(String[] args) {
		Modelo1 obj = new Modelo1("Modelo1");
		obj.run();
	}
	public void run(){
		// first obtain a HlclProgram from the specification
		transformVars();
		transformConstraints(); 
		// use the solver to solve the constraint program
		evaluateSatisfiability();
		//show the output
		System.out.println(prologProgram);
	}
	public void transformVars() {
//declaring variable Modelo1
Identifier Modelo1 = factory.newIdentifier("Modelo1");
  			BinaryDomain Modelo1Dom= new BinaryDomain();
Modelo1.setDomain(Modelo1Dom);	
variables.put("Modelo1", Modelo1); //including the variable in the map
//declaring variable Mainboard
Identifier Mainboard = factory.newIdentifier("Mainboard");
  			BinaryDomain MainboardDom= new BinaryDomain();
Mainboard.setDomain(MainboardDom);	
variables.put("Mainboard", Mainboard); //including the variable in the map
//declaring variable RAM
Identifier RAM = factory.newIdentifier("RAM");
  			BinaryDomain RAMDom= new BinaryDomain();
RAM.setDomain(RAMDom);	
variables.put("RAM", RAM); //including the variable in the map
//declaring variable Socket1151
Identifier Socket1151 = factory.newIdentifier("Socket1151");
  			BinaryDomain Socket1151Dom= new BinaryDomain();
Socket1151.setDomain(Socket1151Dom);	
variables.put("Socket1151", Socket1151); //including the variable in the map
//declaring variable SocketAM4
Identifier SocketAM4 = factory.newIdentifier("SocketAM4");
  			BinaryDomain SocketAM4Dom= new BinaryDomain();
SocketAM4.setDomain(SocketAM4Dom);	
variables.put("SocketAM4", SocketAM4); //including the variable in the map
//declaring variable PowerSupplyUnit
Identifier PowerSupplyUnit = factory.newIdentifier("PowerSupplyUnit");
  			BinaryDomain PowerSupplyUnitDom= new BinaryDomain();
PowerSupplyUnit.setDomain(PowerSupplyUnitDom);	
variables.put("PowerSupplyUnit", PowerSupplyUnit); //including the variable in the map
//declaring variable OpticalDrive
Identifier OpticalDrive = factory.newIdentifier("OpticalDrive");
  			BinaryDomain OpticalDriveDom= new BinaryDomain();
OpticalDrive.setDomain(OpticalDriveDom);	
variables.put("OpticalDrive", OpticalDrive); //including the variable in the map
//declaring variable CPUCooler
Identifier CPUCooler = factory.newIdentifier("CPUCooler");
  			BinaryDomain CPUCoolerDom= new BinaryDomain();
CPUCooler.setDomain(CPUCoolerDom);	
variables.put("CPUCooler", CPUCooler); //including the variable in the map
//declaring variable Socket1151Compatible
Identifier Socket1151Compatible = factory.newIdentifier("Socket1151Compatible");
  			BinaryDomain Socket1151CompatibleDom= new BinaryDomain();
Socket1151Compatible.setDomain(Socket1151CompatibleDom);	
variables.put("Socket1151Compatible", Socket1151Compatible); //including the variable in the map
//declaring variable SocketAM4Compatible
Identifier SocketAM4Compatible = factory.newIdentifier("SocketAM4Compatible");
  			BinaryDomain SocketAM4CompatibleDom= new BinaryDomain();
SocketAM4Compatible.setDomain(SocketAM4CompatibleDom);	
variables.put("SocketAM4Compatible", SocketAM4Compatible); //including the variable in the map
//declaring variable A
Identifier A = factory.newIdentifier("A");
 				RangeDomain ADom= new RangeDomain(1, 4);
A.setDomain(ADom);	
variables.put("A", A); //including the variable in the map
//declaring variable B
Identifier B = factory.newIdentifier("B");
 					 						IntervalDomain BDom= new IntervalDomain(); 
		BDom.add(1); 								BDom.add(2); 								BDom.add(3); 								BDom.add(5); 						
B.setDomain(BDom);	
variables.put("B", B); //including the variable in the map
	}
	public void transformConstraints() {
//
//declaring constraint C_Modelo1


Identifier C_Modelo1_left = variables.get("Modelo1");

NumericIdentifier C_Modelo1_right = getValue("1");
IntBooleanExpression C_Modelo1=
factory.equals(C_Modelo1_left, C_Modelo1_right);
constraints.put("C_Modelo1", C_Modelo1);
hlclProgram.add(C_Modelo1);
//
//declaring constraint C1


Identifier C1_left = variables.get("SocketAM4");

Identifier C1_right = variables.get("SocketAM4Compatible");
IntBooleanExpression C1=factory.implies(C1_left, C1_right);		
constraints.put("C1", C1);
hlclProgram.add(C1);
//
//declaring constraint C2


Identifier C2_left = variables.get("Socket1151");

Identifier C2_right = variables.get("Socket1151Compatible");
IntBooleanExpression C2=factory.implies(C2_left, C2_right);		
constraints.put("C2", C2);
hlclProgram.add(C2);
//
//declaring constraint C3


Identifier C3_left = variables.get("Modelo1");

Identifier C3_right = variables.get("Mainboard");
IntBooleanExpression C3=
factory.equals(C3_left, C3_right);
constraints.put("C3", C3);
hlclProgram.add(C3);
//
//declaring constraint C4


Identifier C4_left = variables.get("Modelo1");

Identifier C4_right = variables.get("RAM");
IntBooleanExpression C4=
factory.equals(C4_left, C4_right);
constraints.put("C4", C4);
hlclProgram.add(C4);
//
//declaring constraint C5


Identifier C5_left = variables.get("Modelo1");

Identifier C5_right = variables.get("PowerSupplyUnit");
IntBooleanExpression C5=
factory.equals(C5_left, C5_right);
constraints.put("C5", C5);
hlclProgram.add(C5);
//
//declaring constraint C6


Identifier C6_left = variables.get("Modelo1");

Identifier C6_right = variables.get("CPUCooler");
IntBooleanExpression C6=
factory.equals(C6_left, C6_right);
constraints.put("C6", C6);
hlclProgram.add(C6);
//
//declaring constraint C7


Identifier C7_left = variables.get("Modelo1");

Identifier C7_right = variables.get("OpticalDrive");
IntBooleanExpression C7=
factory.greaterOrEqualsThan(C7_left, C7_right);
constraints.put("C7", C7);
hlclProgram.add(C7);
//
//declaring constraint C8






Identifier C8_left_left_left_left_left = variables.get("Socket1151");

Identifier C8_left_left_left_left_right = variables.get("Mainboard");
IntBooleanExpression C8_left_left_left_left=factory.implies(C8_left_left_left_left_left, C8_left_left_left_left_right);		


Identifier C8_left_left_left_right_left = variables.get("SocketAM4");

Identifier C8_left_left_left_right_right = variables.get("Mainboard");
IntBooleanExpression C8_left_left_left_right=factory.implies(C8_left_left_left_right_left, C8_left_left_left_right_right);		
IntBooleanExpression C8_left_left_left=factory.and(C8_left_left_left_left, C8_left_left_left_right);		


Identifier C8_left_left_right_left = variables.get("Mainboard");

NumericIdentifier C8_left_left_right_right = getValue("1");
IntBooleanExpression C8_left_left_right=
factory.greaterOrEqualsThan(C8_left_left_right_left, C8_left_left_right_right);
IntBooleanExpression C8_left_left=factory.and(C8_left_left_left, C8_left_left_right);		




Identifier C8_left_right_left_left_left = variables.get("Socket1151");

Identifier C8_left_right_left_left_right = variables.get("SocketAM4");
IntNumericExpression C8_left_right_left_left=factory.sum(C8_left_right_left_left_left, C8_left_right_left_left_right);	

NumericIdentifier C8_left_right_left_right = getValue("1");
IntBooleanExpression C8_left_right_left=
factory.greaterOrEqualsThan(C8_left_right_left_left, C8_left_right_left_right);


Identifier C8_left_right_right_left = variables.get("Mainboard");

NumericIdentifier C8_left_right_right_right = getValue("1");
IntBooleanExpression C8_left_right_right=
factory.greaterOrEqualsThan(C8_left_right_right_left, C8_left_right_right_right);
IntBooleanExpression C8_left_right=factory.and(C8_left_right_left, C8_left_right_right);		
IntBooleanExpression C8_left=factory.implies(C8_left_left, C8_left_right);		



Identifier C8_right_left_left = variables.get("Socket1151");

Identifier C8_right_left_right = variables.get("SocketAM4");
IntNumericExpression C8_right_left=factory.sum(C8_right_left_left, C8_right_left_right);	

NumericIdentifier C8_right_right = getValue("1");
IntBooleanExpression C8_right=
factory.lessOrEqualsThan(C8_right_left, C8_right_right);
IntBooleanExpression C8=factory.implies(C8_left, C8_right);		
constraints.put("C8", C8);
hlclProgram.add(C8);
//
//declaring constraint C9






Identifier C9_left_left_left_left_left = variables.get("SocketAM4Compatible");

Identifier C9_left_left_left_left_right = variables.get("CPUCooler");
IntBooleanExpression C9_left_left_left_left=factory.implies(C9_left_left_left_left_left, C9_left_left_left_left_right);		


Identifier C9_left_left_left_right_left = variables.get("Socket1151Compatible");

Identifier C9_left_left_left_right_right = variables.get("CPUCooler");
IntBooleanExpression C9_left_left_left_right=factory.implies(C9_left_left_left_right_left, C9_left_left_left_right_right);		
IntBooleanExpression C9_left_left_left=factory.and(C9_left_left_left_left, C9_left_left_left_right);		


Identifier C9_left_left_right_left = variables.get("CPUCooler");

NumericIdentifier C9_left_left_right_right = getValue("1");
IntBooleanExpression C9_left_left_right=
factory.greaterOrEqualsThan(C9_left_left_right_left, C9_left_left_right_right);
IntBooleanExpression C9_left_left=factory.and(C9_left_left_left, C9_left_left_right);		




Identifier C9_left_right_left_left_left = variables.get("SocketAM4Compatible");

Identifier C9_left_right_left_left_right = variables.get("Socket1151Compatible");
IntNumericExpression C9_left_right_left_left=factory.sum(C9_left_right_left_left_left, C9_left_right_left_left_right);	

NumericIdentifier C9_left_right_left_right = getValue("1");
IntBooleanExpression C9_left_right_left=
factory.greaterOrEqualsThan(C9_left_right_left_left, C9_left_right_left_right);


Identifier C9_left_right_right_left = variables.get("CPUCooler");

NumericIdentifier C9_left_right_right_right = getValue("1");
IntBooleanExpression C9_left_right_right=
factory.greaterOrEqualsThan(C9_left_right_right_left, C9_left_right_right_right);
IntBooleanExpression C9_left_right=factory.and(C9_left_right_left, C9_left_right_right);		
IntBooleanExpression C9_left=factory.implies(C9_left_left, C9_left_right);		



Identifier C9_right_left_left = variables.get("SocketAM4Compatible");

Identifier C9_right_left_right = variables.get("Socket1151Compatible");
IntNumericExpression C9_right_left=factory.sum(C9_right_left_left, C9_right_left_right);	

NumericIdentifier C9_right_right = getValue("1");
IntBooleanExpression C9_right=
factory.lessOrEqualsThan(C9_right_left, C9_right_right);
IntBooleanExpression C9=factory.implies(C9_left, C9_right);		
constraints.put("C9", C9);
hlclProgram.add(C9);
	}
	public boolean evaluateSatisfiability(){
		// the output
		boolean evaluation= false;
		// //to transform the hllcl program into a prolog  file, 
		// //these lines are commented because they are useful for debugging 
		Hlcl2SWIProlog swiPrologTransformer = new Hlcl2SWIProlog(); 
		prologProgram = swiPrologTransformer.transform(hlclProgram);
				
		// an instance of the solver for Swiprolog 
		swiSolver= new SWIPrologSolver();
		swiSolver.setHLCLProgram(hlclProgram); //passing the hlcl program to the solver
		swiSolver.solve(); // This methhod prepares the solver 
		List<SolverSolution> solutions = swiSolver.getAllSolutions(); // Consulting if the solver has one solution
			evaluation= solutions.size()>0;
			for (SolverSolution solverSolution : solutions) {
				System.out.println(solverSolution.toString());
			}	return evaluation;
	}
	/** 
	* To obtain the NumericIdentifier representation of a value 
	* @param id the string with the value 
	* @return the NumericIdentifier 
	*/
	public NumericIdentifier getValue(String id) {	NumericIdentifier value= numbers.get(id); 
	 	if (value==null) { 
	 		if (id.equals("selected")) { 
	 			value= numbers.get("1"); 
	 		} 
	 		else if(id.equals("unselected")) {
				value= numbers.get("0"); 
			} 
			else { 
				value= factory.number(Integer.parseInt(id)); 
				numbers.put(id, value);
			}
	 	} 
	 	return value; 
	 } 
		public String getModelName() {
			return modelName;
		}
		public void setModelName(String modelName) {
			this.modelName = modelName;
		}
		public HlclFactory getFactory() {
			return factory;
		}
		public void setFactory(HlclFactory factory) {
			this.factory = factory;
		}
		public HlclProgram getHlclProgram() {
			return hlclProgram;
		}
		public void setHlclProgram(HlclProgram hlclProgram) {
			this.hlclProgram = hlclProgram;
		}
} 	
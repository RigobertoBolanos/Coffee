//Java imports
import java.util.HashMap;
import java.util.List;

//imports for hlcl 
import com.variamos.hlcl.core.HlclProgram; 
import com.variamos.hlcl.model.expressions.HlclFactory; 
import com.variamos.hlcl.model.domains.BinaryDomain;
import com.variamos.hlcl.model.domains.IntervalDomain;
import com.variamos.hlcl.model.domains.RangeDomain;
import com.variamos.hlcl.model.expressions.Identifier;
import com.variamos.hlcl.model.expressions.IntBooleanExpression;
import com.variamos.hlcl.model.expressions.NumericIdentifier;
import com.variamos.hlcl.model.expressions.SymbolicExpression;
import com.variamos.hlcl.model.expressions.IntNumericExpression;

//imports for solver
import com.variamos.solver.core.SWIPrologSolver;
import com.variamos.solver.core.compiler.Hlcl2SWIProlog;
import com.variamos.solver.model.SolverSolution;

/**
* This class is automatically generated from a product line model described in 
* extended HLCL
* @author Angela Villota 
* @version PL-HLCL Version1
*
*/
public class PC3 { 				
	
	private String modelName;
	private HlclFactory factory;
	private HlclProgram hlclProgram;
	private SWIPrologSolver swiSolver;
	private String prologProgram;
	private HashMap<String,IntBooleanExpression> constraints;
	private HashMap<String,Identifier> variables;
	private HashMap<String,NumericIdentifier> numbers;
	/**
	* This is an autogenerated method* Constructor method
	* @param modelName is the name of the model in the Extended HLCL specification
	*/
	public PC3(String modelName){ 					
		
		this.modelName= modelName;
		hlclProgram= new HlclProgram();
		factory = new HlclFactory();
		variables= new HashMap<String,Identifier>();
		constraints= new HashMap<String,IntBooleanExpression>();
		numbers= new HashMap<String,NumericIdentifier>();
		NumericIdentifier one = factory.number(1);
		NumericIdentifier zero= factory.number(0);
		numbers.put("1", one);
		numbers.put("0", zero);
	} 				
	public static void main(String[] args) {
		PC3 obj = new PC3("PC3");
		obj.run();
	}
	public void run(){
		// first obtain a HlclProgram from the specification
		transformVars();
		transformConstraints(); 
		// use the solver to solve the constraint program
		evaluateSatisfiability();
		//show the output
		System.out.println(prologProgram);
	}
	public void transformVars() {
		//declaring the variable for the model
		Identifier PC3Var = factory.newIdentifier("PC3");
		BinaryDomain PC3Dom= new BinaryDomain();
		PC3Var.setDomain(PC3Dom);	
		variables.put("PC3Var", PC3Var); //including the variable in the map
		//
		//declaring variable Mainboard
		Identifier Mainboard = factory.newIdentifier("Mainboard");
		BinaryDomain MainboardDom= new BinaryDomain();
		Mainboard.setDomain(MainboardDom);	
		variables.put("Mainboard", Mainboard); //including the variable in the map
		//
		//declaring variable Socket_1151
		Identifier Socket_1151 = factory.newIdentifier("Socket_1151");
		BinaryDomain Socket_1151Dom= new BinaryDomain();
		Socket_1151.setDomain(Socket_1151Dom);	
		variables.put("Socket_1151", Socket_1151); //including the variable in the map
		//
		//declaring variable Socket_AM4
		Identifier Socket_AM4 = factory.newIdentifier("Socket_AM4");
		BinaryDomain Socket_AM4Dom= new BinaryDomain();
		Socket_AM4.setDomain(Socket_AM4Dom);	
		variables.put("Socket_AM4", Socket_AM4); //including the variable in the map
		//
		//declaring variable RAM
		Identifier RAM = factory.newIdentifier("RAM");
		BinaryDomain RAMDom= new BinaryDomain();
		RAM.setDomain(RAMDom);	
		variables.put("RAM", RAM); //including the variable in the map
		//
		//declaring variable Power_Supply_Unit
		Identifier Power_Supply_Unit = factory.newIdentifier("Power_Supply_Unit");
		BinaryDomain Power_Supply_UnitDom= new BinaryDomain();
		Power_Supply_Unit.setDomain(Power_Supply_UnitDom);	
		variables.put("Power_Supply_Unit", Power_Supply_Unit); //including the variable in the map
		//
		//declaring variable Optical_Drive
		Identifier Optical_Drive = factory.newIdentifier("Optical_Drive");
		BinaryDomain Optical_DriveDom= new BinaryDomain();
		Optical_Drive.setDomain(Optical_DriveDom);	
		variables.put("Optical_Drive", Optical_Drive); //including the variable in the map
		//
		//declaring variable CPU_Cooler
		Identifier CPU_Cooler = factory.newIdentifier("CPU_Cooler");
		BinaryDomain CPU_CoolerDom= new BinaryDomain();
		CPU_Cooler.setDomain(CPU_CoolerDom);	
		variables.put("CPU_Cooler", CPU_Cooler); //including the variable in the map
		//
		//declaring variable Socket_1151_compatible
		Identifier Socket_1151_compatible = factory.newIdentifier("Socket_1151_compatible");
		BinaryDomain Socket_1151_compatibleDom= new BinaryDomain();
		Socket_1151_compatible.setDomain(Socket_1151_compatibleDom);	
		variables.put("Socket_1151_compatible", Socket_1151_compatible); //including the variable in the map
		//
		//declaring variable Socket_AM4_compatible
		Identifier Socket_AM4_compatible = factory.newIdentifier("Socket_AM4_compatible");
		BinaryDomain Socket_AM4_compatibleDom= new BinaryDomain();
		Socket_AM4_compatible.setDomain(Socket_AM4_compatibleDom);	
		variables.put("Socket_AM4_compatible", Socket_AM4_compatible); //including the variable in the map
	}
	public void transformConstraints() {
		//declaring the constraint for the model
		IntBooleanExpression CPC3= factory.equals(variables.get("PC3Var"), getValue("1"));
		constraints.put("CPC3", CPC3);
		hlclProgram.add(CPC3);
		//
		//declaring constraint C1
		IntBooleanExpression C1= factory.equals(variables.get("PC3Var"), variables.get("Mainboard"));
		constraints.put("C1", C1);
		hlclProgram.add(C1);
		//
		//declaring constraint C3
		constraints.put("C3", C3);
		hlclProgram.add(C3);
		//
		//declaring constraint C4
		IntBooleanExpression C4= factory.equals(variables.get("PC3Var"), variables.get("Power_Supply_Unit"));
		constraints.put("C4", C4);
		hlclProgram.add(C4);
		//
		//declaring constraint C6
		IntBooleanExpression C6= factory.equals(variables.get("PC3Var"), variables.get("CPU_Cooler"));
		constraints.put("C6", C6);
		hlclProgram.add(C6);
		//
		//declaring constraint C5
		IntBooleanExpression C5= factory.greaterOrEqualsThan(variables.get("PC3Var"), variables.get("Optical_Drive"));
		constraints.put("C5", C5);
		hlclProgram.add(C5);
		//
		//declaring constraint C8
		IntBooleanExpression C8= factory.implies(variables.get("Socket_AM4"), variables.get("Socket_AM4_compatible"));
		constraints.put("C8", C8);
		hlclProgram.add(C8);
		//
		//declaring constraint C9
		IntBooleanExpression C9= factory.implies(variables.get("Socket_1151"), variables.get("Socket_1151_compatible"));
		constraints.put("C9", C9);
		hlclProgram.add(C9);
		//
		//declaring constraint C2
		//implies
		IntBooleanExpression Socket_1151Imp= factory.implies(variables.get("Socket_1151"), variables.get("Mainboard"));
		constraints.put("Socket_1151Imp", Socket_1151Imp);
		hlclProgram.add(Socket_1151Imp);
		IntBooleanExpression Socket_AM4Imp= factory.implies(variables.get("Socket_AM4"), variables.get("Mainboard"));
		constraints.put("Socket_AM4Imp", Socket_AM4Imp);
		hlclProgram.add(Socket_AM4Imp);
		//sum
		IntNumericExpression plusC2=factory.sum(variables.get("Socket_1151"),variables.get("Socket_AM4"));
		
		// selection of parent
		IntBooleanExpression parentSelectionC2= factory.greaterOrEqualsThan(variables.get("Mainboard"), getValue("1"));
		
		//plusMin
		IntBooleanExpression plusGTMinC2= factory.greaterOrEqualsThan(plusC2, getValue("1"));
		
		//plusMax
		IntBooleanExpression plusLTMaxC2= factory.lessOrEqualsThan(plusC2, getValue("1"));
		
		IntBooleanExpression leftC2=factory.implies(parentSelectionC2,plusGTMinC2);
		IntBooleanExpression rightC2=factory.implies(parentSelectionC2, plusLTMaxC2);
		IntBooleanExpression C2=factory.and(leftC2, rightC2);
		constraints.put("C2", C2);
		hlclProgram.add(C2);
		//
		//declaring constraint C7
		//implies
		IntBooleanExpression Socket_1151_compatibleImp= factory.implies(variables.get("Socket_1151_compatible"), variables.get("CPU_Cooler"));
		constraints.put("Socket_1151_compatibleImp", Socket_1151_compatibleImp);
		hlclProgram.add(Socket_1151_compatibleImp);
		IntBooleanExpression Socket_AM4_compatibleImp= factory.implies(variables.get("Socket_AM4_compatible"), variables.get("CPU_Cooler"));
		constraints.put("Socket_AM4_compatibleImp", Socket_AM4_compatibleImp);
		hlclProgram.add(Socket_AM4_compatibleImp);
		//sum
		IntNumericExpression plusC7=factory.sum(variables.get("Socket_1151_compatible"),variables.get("Socket_AM4_compatible"));
		
		// selection of parent
		IntBooleanExpression parentSelectionC7= factory.greaterOrEqualsThan(variables.get("CPU_Cooler"), getValue("1"));
		
		//plusMin
		IntBooleanExpression plusGTMinC7= factory.greaterOrEqualsThan(plusC7, getValue("1"));
		
		//plusMax
		IntBooleanExpression plusLTMaxC7= factory.lessOrEqualsThan(plusC7, getValue("3"));
		
		IntBooleanExpression leftC7=factory.implies(parentSelectionC7,plusGTMinC7);
		IntBooleanExpression rightC7=factory.implies(parentSelectionC7, plusLTMaxC7);
		IntBooleanExpression C7=factory.and(leftC7, rightC7);
		constraints.put("C7", C7);
		hlclProgram.add(C7);
	}
	public boolean evaluateSatisfiability(){
		// the output
		boolean evaluation= false;
		// //to transform the hllcl program into a prolog  file, 
		// //these lines are commented because they are useful for debugging 
		Hlcl2SWIProlog swiPrologTransformer = new Hlcl2SWIProlog(); 
		prologProgram = swiPrologTransformer.transform(hlclProgram);
				
		// an instance of the solver for Swiprolog 
		swiSolver= new SWIPrologSolver();
		swiSolver.setHLCLProgram(hlclProgram); //passing the hlcl program to the solver
		swiSolver.solve(); // This methhod prepares the solver 
		List<SolverSolution> solutions = swiSolver.getAllSolutions(); // Consulting if the solver has one solution
			evaluation= solutions.size()>0;
			for (SolverSolution solverSolution : solutions) {
				System.out.println(solverSolution.toString());
			}	return evaluation;
	}
	/** 
	* To obtain the NumericIdentifier representation of a value 
	* @param id the string with the value 
	* @return the NumericIdentifier 
	*/
	public NumericIdentifier getValue(String id) {	NumericIdentifier value= numbers.get(id); 
	 	if (value==null) { 
	 		if (id.equals("selected")) { 
	 			value= numbers.get("1"); 
	 		} 
	 		else if(id.equals("unselected")) {
				value= numbers.get("0"); 
			} 
			else { 
				value= factory.number(Integer.parseInt(id)); 
				numbers.put(id, value);
			}
	 	} 
	 	return value; 
	 } 
		public String getModelName() {
			return modelName;
		}
		public void setModelName(String modelName) {
			this.modelName = modelName;
		}
		public HlclFactory getFactory() {
			return factory;
		}
		public void setFactory(HlclFactory factory) {
			this.factory = factory;
		}
		public HlclProgram getHlclProgram() {
			return hlclProgram;
		}
		public void setHlclProgram(HlclProgram hlclProgram) {
			this.hlclProgram = hlclProgram;
		}
} 	
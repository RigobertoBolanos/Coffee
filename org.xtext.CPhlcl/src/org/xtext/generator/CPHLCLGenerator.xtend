/*
 * generated by Xtext 2.12.0
 */
package org.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.cPHLCL.Model

import org.xtext.cPHLCL.DomainDeclaration
import org.xtext.cPHLCL.Interval
import org.xtext.cPHLCL.Enumeration
import org.xtext.cPHLCL.Expression
import org.xtext.cPHLCL.Global
import org.xtext.cPHLCL.ListOfIDs
import org.xtext.cPHLCL.VarDeclaration
import org.xtext.cPHLCL.Logic
import org.xtext.cPHLCL.BoolExpression

import org.xtext.cPHLCL.BoolVar
import org.xtext.cPHLCL.ComplexTerm
import org.xtext.cPHLCL.LogicUn
import org.xtext.cPHLCL.Relational
import org.xtext.cPHLCL.NumExpression
import org.xtext.cPHLCL.IntVar
import org.xtext.cPHLCL.Arithmetic
//import org.xtext.cPHLCL.IntegerExp

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CPHLCLGenerator extends AbstractGenerator implements JavaCodeStrings{
	private String modelName

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		modelName= modelName(resource.contents.head as Model)
		fsa.generateFile(modelName+".java", toJavaCode(resource.contents.head as Model))

	}
	def modelName(Model model) {
		var name = model.name.toFirstUpper
		return name
	}
	def className(Resource res) {
		var name = res.URI.lastSegment
		println(name);
		return name.substring(0, name.indexOf('.'))
	}
		def toJavaCode(Model model) '''
			//Java imports
			«JAVA_IMPORTS»
			
			//imports for hlcl 
			«HLCL_IMPORTS»
			
			//imports for solver
			«SOLVER_IMPORTS»

			«CLASS_JAVADOC»
			«CLASS_DECLARATION» «modelName» { ««« open class
				
				«CLASS_ATTRIBUTES»
				«CONSTRUCTOR_JAVADOC»
				public «modelName»(String modelName){ «««Consructor declaration
					
					«CONSTRUCTOR_CODE»
				} ««« end Consructor 
				
				public static void main(String[] args) {
					«modelName» obj = new «modelName»("«modelName»");
					obj.run();
				}
				«RUN_METHOD»
				public void transformVars() {
					//declaring the variable for the model
					Identifier «modelName»Var = factory.newIdentifier("«modelName»");
					BinaryDomain «modelName»Dom= new BinaryDomain();
					«modelName»Var.setDomain(«modelName»Dom);	
					variables.put("«modelName»Var", «modelName»Var); //including the variable in the map
					«FOR c : model.vars»
						«c.declareVars»
					«ENDFOR»
				}
				public void transformConstraints() {
					//declaring the constraint for the model
					IntBooleanExpression C«modelName»= factory.equals(variables.get("«modelName»Var"), getValue("1"));
					constraints.put("C«modelName»", C«modelName»);
					hlclProgram.add(C«modelName»);
					«FOR c : model.constraints»
						«declareCons(c.exp, c.name)»
					«ENDFOR»
				}
				«EVALUATE_SATISFIABILITY»
				«GET_VALUE_JAVADOC»
				«GET_VALUE_CODE»
				«GETTERS_SETTERS»
			} ««« ends Class
	'''
	def declareVars(VarDeclaration variable) '''
		//declaring variable «variable.name»
		Identifier «variable.name» = factory.newIdentifier("«variable.name»");
		«var String myType= variable.type.toString»
		«declareDomain(variable.domain, myType, variable.name)»
		variables.put("«variable.name»", «variable.name»); //including the variable in the map
	'''
	
	def declareDomain(DomainDeclaration domain, String type, String name) '''
		«IF type.equals("bool")»  ««« the domain is of type boolean
			BinaryDomain «name»Dom= new BinaryDomain();
		«ELSE»	
			«IF domain instanceof Interval» ««« the domain is numeric, and declared as an interval
				RangeDomain «name»Dom= new RangeDomain(«domain.start», «domain.end»);
			«ELSE»
				«IF domain instanceof Enumeration» ««« the domain is declared as an enumeration
					«IF type.equals("symbolic")» ««« if the domain is an enumeration of strings (symbolic)
						StringDomain «name»Dom= new StringDomain();
						«FOR e : domain.list.values»
							«name»Dom.add("«e»"); ««« add each element in the enumeration as a string
						«ENDFOR»
					«ELSE» ««« if the domain is an enumeration of numbers
						IntervalDomain «name»Dom= new IntervalDomain(); 
						«FOR e : domain.list.values»
							«name»Dom.add(«e»); ««« add each element in the enumeration
						«ENDFOR»
					«ENDIF»	
				«ENDIF»
			«ENDIF»
		«ENDIF»
		«name».setDomain(«name»Dom);	
	'''
	
	def declareCons(Expression exp, String name) '''
		//
		//declaring constraint «name»
		«IF exp instanceof Global»
			«declareGlobal(exp, name)»
		«ELSE»
			«IF exp instanceof Logic»
				«declareLogic(exp, name)»
			«ELSE»
				«IF exp instanceof Relational»
					«declareRelational(exp, name)»
«««					«var Rule rule= exp as Rule»
«««					«declareRule(rule, name)»
«««				«ELSE»
«««					«IF exp instanceof FodaNary»
«««						«var FodaNary nary= exp as FodaNary»
«««						«declareNary(nary, name)»
«««					«ELSE»
«««						«var FodaUN unary= exp as FodaUN»
«««						«declareFodaUnary(unary, name)»
«««					«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
		constraints.put("«name»", «name»);
		hlclProgram.add(«name»);
	'''
	def declareGlobal(Global exp, String name) '''
		SymbolicExpression «name»= factory.newSymbolic("«exp.op»"«declareIds(exp.vars)»);
		
	'''
	def declareIds(ListOfIDs idList) '''
		«FOR id : idList.ids»
			, variables.get("«id»")
		«ENDFOR»
	'''
	def declareRelational(Relational exp, String name) '''
		«declareNumericTerm(exp.relationalLeft, name+"_left")»
		«declareNumericTerm(exp.relationalRight, name+"_right")»
		IntBooleanExpression «name»=
		«IF exp.relationalOp.equals(">") »
			factory.greaterThan(«name»_left, «name»_right);
		«ELSE»
			«IF exp.relationalOp.equals(">=") »
				factory.greaterOrEqualsThan(«name»_left, «name»_right);
			«ELSE»
				«IF exp.relationalOp.equals("<") »
					factory.lessThan(«name»_left, «name»_right);
				«ELSE»
					«IF exp.relationalOp.equals("<=") »
						factory.lessOrEqualsThan(«name»_left, «name»_right);
					«ELSE»
						«IF exp.relationalOp.equals("=") »
							factory.equals(«name»_left, «name»_right);
						«ELSE»
							«IF exp.relationalOp.equals("!=") »
								factory.notEquals(«name»_left, «name»_right);
							«ENDIF»						
						«ENDIF»
					«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»		

	'''
	def declareLogic(Logic exp, String name) '''
		«declareBoolTerm(exp.logicLeft, name+"_left")»
		«declareBoolTerm(exp.logicRight, name+"_right")»
		IntBooleanExpression «name»=
		«IF exp.logicOp.equals("AND") »
			factory.and(«name»_left, «name»_right);
		«ELSE»
			«IF exp.logicOp.equals("OR") »
				factory.or(«name»_left, «name»_right);
			«ELSE»
				«IF exp.logicOp.equals("XOR") »
					factory.xor(«name»_left, «name»_right);
				«ELSE»
					«IF exp.logicOp.equals("=>") »
						factory.implies(«name»_left, «name»_right);
					«ELSE»
						«IF exp.logicOp.equals("<=>") »
							factory.doubleImplies(«name»_left, «name»_right);
						«ENDIF»
					«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
	'''
	def declareBoolTerm(BoolExpression exp, String name) '''
		«IF exp instanceof BoolVar»
			Identifier «name» = variables.get("«exp.id»");
		«ELSE»
			«IF exp instanceof ComplexTerm»
				«IF exp instanceof Logic»
					«declareLogic(exp, name)»
				«ELSE»
					«IF exp instanceof LogicUn»
						«declareBoolTerm(exp.exp, name+"_int")»
						IntBooleanExpression «name»=factory.not(«name»_int);
					«ELSE»
					«ENDIF»	
				«ENDIF»									
			«ENDIF»
		«ENDIF»
	'''
	def declareNumericTerm(NumExpression exp, String name) '''
		«IF exp instanceof Number»
			// there is a number in the parser
			NumericIdentifier «name» = getValue("«exp»");
		«ELSE»
			«IF exp instanceof IntVar»
				Identifier «name» = variables.get("«exp.id»");	
			«ELSE»
				«IF exp instanceof Arithmetic»
					«declareArithmetic(exp, name)»
				«ELSE»
«««					«IF exp instanceof IntegerExp»
«««						«declareIntegerExp(exp, name)»
«««					«ENDIF»
				«ENDIF»	
			«ENDIF»									
		«ENDIF»
	'''
	def declareArithmetic(Arithmetic exp, String name) '''
		«declareNumericTerm(exp.left, name+"_left")»
		«declareNumericTerm(exp.right, name+"_right")»
		IntNumericExpression «name»=
		«IF exp.arithOperator.equals("+") »
					factory.sum(«name»_left, «name»_right);
				«ELSE»
					«IF exp.arithOperator.equals("-") »
						factory.diff(«name»_left, «name»_right);
					«ELSE»
						«IF exp.arithOperator.equals("*") »
							factory.prod(«name»_left, «name»_right);
«««						«ELSE»
«««							«IF exp.arithOperator.equals("/") »
«««								factory.implies(«name»_left, «name»_right);
«««							«ELSE»
«««								«IF exp.arithOperator.equals("<=>") »
«««									factory.doubleImplies(«name»_left, «name»_right);
«««								«ENDIF»
«««							«ENDIF»
						«ENDIF»
					«ENDIF»
				«ENDIF»
	'''
//	def declareIntegerExp(IntegerExp exp, String name) '''
//
//	'''
}

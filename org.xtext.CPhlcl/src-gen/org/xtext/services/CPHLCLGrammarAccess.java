/*
 * generated by Xtext 2.12.0
 */
package org.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class CPHLCLGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cVariablesKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVarsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVarsVarDeclarationParserRuleCall_3_0 = (RuleCall)cVarsAssignment_3.eContents().get(0);
		private final Keyword cConstraintsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cConstraintsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cConstraintsConstraintParserRuleCall_5_0 = (RuleCall)cConstraintsAssignment_5.eContents().get(0);
		private final Keyword cStrategyKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cStrategyAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cStrategyStrategyParserRuleCall_7_0 = (RuleCall)cStrategyAssignment_7.eContents().get(0);
		
		//// A CSP is composed by a set of variables with their domains, a set of constraints and a series of search strategies
		//Model:
		//	'model' name=ID 'variables:' vars+=VarDeclaration+ 'constraints:' constraints+=Constraint+
		//	'strategy:' strategy=Strategy;
		@Override public ParserRule getRule() { return rule; }
		
		//'model' name=ID 'variables:' vars+=VarDeclaration+ 'constraints:' constraints+=Constraint+ 'strategy:' strategy=Strategy
		public Group getGroup() { return cGroup; }
		
		//'model'
		public Keyword getModelKeyword_0() { return cModelKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'variables:'
		public Keyword getVariablesKeyword_2() { return cVariablesKeyword_2; }
		
		//vars+=VarDeclaration+
		public Assignment getVarsAssignment_3() { return cVarsAssignment_3; }
		
		//VarDeclaration
		public RuleCall getVarsVarDeclarationParserRuleCall_3_0() { return cVarsVarDeclarationParserRuleCall_3_0; }
		
		//'constraints:'
		public Keyword getConstraintsKeyword_4() { return cConstraintsKeyword_4; }
		
		//constraints+=Constraint+
		public Assignment getConstraintsAssignment_5() { return cConstraintsAssignment_5; }
		
		//Constraint
		public RuleCall getConstraintsConstraintParserRuleCall_5_0() { return cConstraintsConstraintParserRuleCall_5_0; }
		
		//'strategy:'
		public Keyword getStrategyKeyword_6() { return cStrategyKeyword_6; }
		
		//strategy=Strategy
		public Assignment getStrategyAssignment_7() { return cStrategyAssignment_7; }
		
		//Strategy
		public RuleCall getStrategyStrategyParserRuleCall_7_0() { return cStrategyStrategyParserRuleCall_7_0; }
	}
	public class VarDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.VarDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeVarTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cDomainKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDomainAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDomainDomainDeclarationParserRuleCall_3_0 = (RuleCall)cDomainAssignment_3.eContents().get(0);
		
		////VAriables and domains declarations	
		//VarDeclaration:
		//	type=VarType name=ID 'domain:' domain=DomainDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//type=VarType name=ID 'domain:' domain=DomainDeclaration
		public Group getGroup() { return cGroup; }
		
		//type=VarType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//VarType
		public RuleCall getTypeVarTypeParserRuleCall_0_0() { return cTypeVarTypeParserRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'domain:'
		public Keyword getDomainKeyword_2() { return cDomainKeyword_2; }
		
		//domain=DomainDeclaration
		public Assignment getDomainAssignment_3() { return cDomainAssignment_3; }
		
		//DomainDeclaration
		public RuleCall getDomainDomainDeclarationParserRuleCall_3_0() { return cDomainDomainDeclarationParserRuleCall_3_0; }
	}
	public class DomainDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.DomainDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntervalParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumerationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//DomainDeclaration:
		//	Interval | Enumeration //| Mixed //domains
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Interval | Enumeration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Interval
		public RuleCall getIntervalParserRuleCall_0() { return cIntervalParserRuleCall_0; }
		
		//Enumeration
		public RuleCall getEnumerationParserRuleCall_1() { return cEnumerationParserRuleCall_1; }
	}
	public class IntervalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Interval");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStartAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStartEnumerableValueParserRuleCall_0_0 = (RuleCall)cStartAssignment_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndEnumerableValueParserRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//Interval:
		//	start=EnumerableValue '..' end=EnumerableValue;
		@Override public ParserRule getRule() { return rule; }
		
		//start=EnumerableValue '..' end=EnumerableValue
		public Group getGroup() { return cGroup; }
		
		//start=EnumerableValue
		public Assignment getStartAssignment_0() { return cStartAssignment_0; }
		
		//EnumerableValue
		public RuleCall getStartEnumerableValueParserRuleCall_0_0() { return cStartEnumerableValueParserRuleCall_0_0; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }
		
		//end=EnumerableValue
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }
		
		//EnumerableValue
		public RuleCall getEndEnumerableValueParserRuleCall_2_0() { return cEndEnumerableValueParserRuleCall_2_0; }
	}
	public class EnumerationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Enumeration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cListListOfValuesParserRuleCall_1_0 = (RuleCall)cListAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Enumeration:
		//	'[' list=ListOfValues ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' list=ListOfValues ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//list=ListOfValues
		public Assignment getListAssignment_1() { return cListAssignment_1; }
		
		//ListOfValues
		public RuleCall getListListOfValuesParserRuleCall_1_0() { return cListListOfValuesParserRuleCall_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class ConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Constraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpExpressionParserRuleCall_2_0 = (RuleCall)cExpAssignment_2.eContents().get(0);
		
		///**
		// * Constraints and constraints declarations
		// */ Constraint:
		//	name=ID ':' exp=Expression
		//	//|BoolExpression//|Relational|Global
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' exp=Expression
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//exp=Expression
		public Assignment getExpAssignment_2() { return cExpAssignment_2; }
		
		//Expression
		public RuleCall getExpExpressionParserRuleCall_2_0() { return cExpExpressionParserRuleCall_2_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGlobalParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLogicParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRelationalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cControlParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Expression:
		//	Global | Logic | Relational | Control
		//	//Global|Logic|Relational|IntegerExp|Arithmetic|Control
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////Global|Logic|Relational|Arithmetic|Control
		//Global | Logic | Relational | Control
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////Global|Logic|Relational|Arithmetic|Control
		//Global
		public RuleCall getGlobalParserRuleCall_0() { return cGlobalParserRuleCall_0; }
		
		//Logic
		public RuleCall getLogicParserRuleCall_1() { return cLogicParserRuleCall_1; }
		
		//Relational
		public RuleCall getRelationalParserRuleCall_2() { return cRelationalParserRuleCall_2; }
		
		//Control
		public RuleCall getControlParserRuleCall_3() { return cControlParserRuleCall_3; }
	}
	public class BoolTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.BoolTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cComplexTermParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cBoolVarParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////BooleanExpression:
		////	Logic|Relational
		////;
		//BoolTerm BoolExpression: //'('Logic')'|Bool
		//	'(' ComplexTerm ')' | BoolVar;
		@Override public ParserRule getRule() { return rule; }
		
		////'('Logic')'|Bool
		//'(' ComplexTerm ')' | BoolVar
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////'('Logic')'|Bool
		//'(' ComplexTerm ')'
		public Group getGroup_0() { return cGroup_0; }
		
		////'('Logic')'|Bool
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//ComplexTerm
		public RuleCall getComplexTermParserRuleCall_0_1() { return cComplexTermParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//BoolVar
		public RuleCall getBoolVarParserRuleCall_1() { return cBoolVarParserRuleCall_1; }
	}
	public class ComplexTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.ComplexTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLogicParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRelationalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLogicUnParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ComplexTerm:
		//	Logic | Relational | LogicUn;
		@Override public ParserRule getRule() { return rule; }
		
		//Logic | Relational | LogicUn
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Logic
		public RuleCall getLogicParserRuleCall_0() { return cLogicParserRuleCall_0; }
		
		//Relational
		public RuleCall getRelationalParserRuleCall_1() { return cRelationalParserRuleCall_1; }
		
		//LogicUn
		public RuleCall getLogicUnParserRuleCall_2() { return cLogicUnParserRuleCall_2; }
	}
	public class LogicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Logic");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLogicLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLogicLeftBoolTermParserRuleCall_0_0 = (RuleCall)cLogicLeftAssignment_0.eContents().get(0);
		private final Assignment cLogicOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLogicOpLogicOpBinParserRuleCall_1_0 = (RuleCall)cLogicOpAssignment_1.eContents().get(0);
		private final Assignment cLogicRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLogicRightBoolTermParserRuleCall_2_0 = (RuleCall)cLogicRightAssignment_2.eContents().get(0);
		
		//Logic:
		//	=> logicLeft=BoolTerm
		//	logicOp=LogicOpBin
		//	=> logicRight=BoolTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//=> logicLeft=BoolTerm logicOp=LogicOpBin => logicRight=BoolTerm
		public Group getGroup() { return cGroup; }
		
		//=> logicLeft=BoolTerm
		public Assignment getLogicLeftAssignment_0() { return cLogicLeftAssignment_0; }
		
		//BoolTerm
		public RuleCall getLogicLeftBoolTermParserRuleCall_0_0() { return cLogicLeftBoolTermParserRuleCall_0_0; }
		
		//logicOp=LogicOpBin
		public Assignment getLogicOpAssignment_1() { return cLogicOpAssignment_1; }
		
		//LogicOpBin
		public RuleCall getLogicOpLogicOpBinParserRuleCall_1_0() { return cLogicOpLogicOpBinParserRuleCall_1_0; }
		
		//=> logicRight=BoolTerm
		public Assignment getLogicRightAssignment_2() { return cLogicRightAssignment_2; }
		
		//BoolTerm
		public RuleCall getLogicRightBoolTermParserRuleCall_2_0() { return cLogicRightBoolTermParserRuleCall_2_0; }
	}
	public class LogicUnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.LogicUn");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLogicOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLogicOpLogicOpUnParserRuleCall_0_0 = (RuleCall)cLogicOpAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpBoolTermParserRuleCall_2_0 = (RuleCall)cExpAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//LogicUn:
		//	logicOp=LogicOpUn '(' exp=BoolTerm ')';
		@Override public ParserRule getRule() { return rule; }
		
		//logicOp=LogicOpUn '(' exp=BoolTerm ')'
		public Group getGroup() { return cGroup; }
		
		//logicOp=LogicOpUn
		public Assignment getLogicOpAssignment_0() { return cLogicOpAssignment_0; }
		
		//LogicOpUn
		public RuleCall getLogicOpLogicOpUnParserRuleCall_0_0() { return cLogicOpLogicOpUnParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//exp=BoolTerm
		public Assignment getExpAssignment_2() { return cExpAssignment_2; }
		
		//BoolTerm
		public RuleCall getExpBoolTermParserRuleCall_2_0() { return cExpBoolTermParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class RelationalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Relational");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRelationalLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRelationalLeftNumericTermParserRuleCall_0_0 = (RuleCall)cRelationalLeftAssignment_0.eContents().get(0);
		private final Assignment cRelationalOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelationalOpRelationalOpParserRuleCall_1_0 = (RuleCall)cRelationalOpAssignment_1.eContents().get(0);
		private final Assignment cRelationalRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationalRightNumericTermParserRuleCall_2_0 = (RuleCall)cRelationalRightAssignment_2.eContents().get(0);
		
		//Relational:
		//	=> relationalLeft=NumericTerm
		//	relationalOp=RelationalOp
		//	=> relationalRight=NumericTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//=> relationalLeft=NumericTerm relationalOp=RelationalOp => relationalRight=NumericTerm
		public Group getGroup() { return cGroup; }
		
		//=> relationalLeft=NumericTerm
		public Assignment getRelationalLeftAssignment_0() { return cRelationalLeftAssignment_0; }
		
		//NumericTerm
		public RuleCall getRelationalLeftNumericTermParserRuleCall_0_0() { return cRelationalLeftNumericTermParserRuleCall_0_0; }
		
		//relationalOp=RelationalOp
		public Assignment getRelationalOpAssignment_1() { return cRelationalOpAssignment_1; }
		
		//RelationalOp
		public RuleCall getRelationalOpRelationalOpParserRuleCall_1_0() { return cRelationalOpRelationalOpParserRuleCall_1_0; }
		
		//=> relationalRight=NumericTerm
		public Assignment getRelationalRightAssignment_2() { return cRelationalRightAssignment_2; }
		
		//NumericTerm
		public RuleCall getRelationalRightNumericTermParserRuleCall_2_0() { return cRelationalRightNumericTermParserRuleCall_2_0; }
	}
	public class NumericTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.NumericTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cArithmeticParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cNumberParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntVarParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////
		////NumericExpression:
		////	 IntegerExp |Arithmetic
		////	 
		////;
		//NumericTerm NumExpression: //'(' Arithmetic ')' | Number
		////'('Arithmetic')' |'(' IntegerExp ')' | Number |IntVar
		//	'(' Arithmetic ')' | Number | IntVar;
		@Override public ParserRule getRule() { return rule; }
		
		////'(' Arithmetic ')' | Number
		////'('Arithmetic')' |'(' IntegerExp ')' | Number |IntVar
		//'(' Arithmetic ')' | Number | IntVar
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////'(' Arithmetic ')' | Number
		////'('Arithmetic')' |'(' IntegerExp ')' | Number |IntVar
		//'(' Arithmetic ')'
		public Group getGroup_0() { return cGroup_0; }
		
		////'(' Arithmetic ')' | Number
		////'('Arithmetic')' |'(' IntegerExp ')' | Number |IntVar
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Arithmetic
		public RuleCall getArithmeticParserRuleCall_0_1() { return cArithmeticParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//Number
		public RuleCall getNumberParserRuleCall_1() { return cNumberParserRuleCall_1; }
		
		//IntVar
		public RuleCall getIntVarParserRuleCall_2() { return cIntVarParserRuleCall_2; }
	}
	public class ArithmeticElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Arithmetic");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftNumericTermParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Assignment cArithOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArithOperatorArithmeticOpParserRuleCall_1_0 = (RuleCall)cArithOperatorAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightNumericTermParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//Arithmetic:
		//	left=NumericTerm
		//	arithOperator=ArithmeticOp
		//	right=NumericTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//left=NumericTerm arithOperator=ArithmeticOp right=NumericTerm
		public Group getGroup() { return cGroup; }
		
		//left=NumericTerm
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//NumericTerm
		public RuleCall getLeftNumericTermParserRuleCall_0_0() { return cLeftNumericTermParserRuleCall_0_0; }
		
		//arithOperator=ArithmeticOp
		public Assignment getArithOperatorAssignment_1() { return cArithOperatorAssignment_1; }
		
		//ArithmeticOp
		public RuleCall getArithOperatorArithmeticOpParserRuleCall_1_0() { return cArithOperatorArithmeticOpParserRuleCall_1_0; }
		
		//right=NumericTerm
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//NumericTerm
		public RuleCall getRightNumericTermParserRuleCall_2_0() { return cRightNumericTermParserRuleCall_2_0; }
	}
	public class GlobalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Global");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOpGlobalOpParserRuleCall_0_0 = (RuleCall)cOpAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cVarsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cVarsListOfIDsParserRuleCall_2_0 = (RuleCall)cVarsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////ArithmeticUn:
		////	
		////;
		////IntegerExp:
		////	intOperator=IntegerOp '(' values=ListOfEnumerables ')'  
		////	;
		///**
		// * Global constraints
		// */ Global:
		//	op=GlobalOp '(' vars=ListOfIDs ')';
		@Override public ParserRule getRule() { return rule; }
		
		//op=GlobalOp '(' vars=ListOfIDs ')'
		public Group getGroup() { return cGroup; }
		
		//op=GlobalOp
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//GlobalOp
		public RuleCall getOpGlobalOpParserRuleCall_0_0() { return cOpGlobalOpParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//vars=ListOfIDs
		public Assignment getVarsAssignment_2() { return cVarsAssignment_2; }
		
		//ListOfIDs
		public RuleCall getVarsListOfIDsParserRuleCall_2_0() { return cVarsListOfIDsParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ControlElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Control");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCondAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCondBoolTermParserRuleCall_2_0 = (RuleCall)cCondAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cThenKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTrueStatementAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cTrueStatementExpressionParserRuleCall_5_0 = (RuleCall)cTrueStatementAssignment_5.eContents().get(0);
		private final Keyword cElseKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cElseStatementAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cElseStatementExpressionParserRuleCall_7_0 = (RuleCall)cElseStatementAssignment_7.eContents().get(0);
		private final Keyword cEnd_ifKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		///*
		// * Control statement if-then-else
		// */ Control:
		//	'if' '(' cond=BoolTerm ')' 'then' trueStatement=Expression 'else' elseStatement=Expression 'end_if';
		@Override public ParserRule getRule() { return rule; }
		
		//'if' '(' cond=BoolTerm ')' 'then' trueStatement=Expression 'else' elseStatement=Expression 'end_if'
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//cond=BoolTerm
		public Assignment getCondAssignment_2() { return cCondAssignment_2; }
		
		//BoolTerm
		public RuleCall getCondBoolTermParserRuleCall_2_0() { return cCondBoolTermParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'then'
		public Keyword getThenKeyword_4() { return cThenKeyword_4; }
		
		//trueStatement=Expression
		public Assignment getTrueStatementAssignment_5() { return cTrueStatementAssignment_5; }
		
		//Expression
		public RuleCall getTrueStatementExpressionParserRuleCall_5_0() { return cTrueStatementExpressionParserRuleCall_5_0; }
		
		//'else'
		public Keyword getElseKeyword_6() { return cElseKeyword_6; }
		
		//elseStatement=Expression
		public Assignment getElseStatementAssignment_7() { return cElseStatementAssignment_7; }
		
		//Expression
		public RuleCall getElseStatementExpressionParserRuleCall_7_0() { return cElseStatementExpressionParserRuleCall_7_0; }
		
		//'end_if'
		public Keyword getEnd_ifKeyword_8() { return cEnd_ifKeyword_8; }
	}
	public class StrategyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Strategy");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cOneKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cTwoKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		////Strategies
		//Strategy:
		//	'one' | 'two';
		@Override public ParserRule getRule() { return rule; }
		
		//'one' | 'two'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'one'
		public Keyword getOneKeyword_0() { return cOneKeyword_0; }
		
		//'two'
		public Keyword getTwoKeyword_1() { return cTwoKeyword_1; }
	}
	public class BoolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Bool");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValBoolValParserRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		////Terminals and categories
		//Bool:
		//	val=BoolVal;
		@Override public ParserRule getRule() { return rule; }
		
		//val=BoolVal
		public Assignment getValAssignment() { return cValAssignment; }
		
		//BoolVal
		public RuleCall getValBoolValParserRuleCall_0() { return cValBoolValParserRuleCall_0; }
	}
	public class BoolValElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.BoolVal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//BoolVal:
		//	'true' | 'false';
		@Override public ParserRule getRule() { return rule; }
		
		//'true' | 'false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'true'
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }
		
		//'false'
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}
	public class BoolVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.BoolVar");
		private final Assignment cIdAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_0 = (RuleCall)cIdAssignment.eContents().get(0);
		
		//BoolVar:
		//	id=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//id=ID
		public Assignment getIdAssignment() { return cIdAssignment; }
		
		//ID
		public RuleCall getIdIDTerminalRuleCall_0() { return cIdIDTerminalRuleCall_0; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Number");
		private final Assignment cNumAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNumINTTerminalRuleCall_0 = (RuleCall)cNumAssignment.eContents().get(0);
		
		//Number:
		//	num=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//num=INT
		public Assignment getNumAssignment() { return cNumAssignment; }
		
		//INT
		public RuleCall getNumINTTerminalRuleCall_0() { return cNumINTTerminalRuleCall_0; }
	}
	public class IntVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.IntVar");
		private final Assignment cIdAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdIDTerminalRuleCall_0 = (RuleCall)cIdAssignment.eContents().get(0);
		
		//IntVar:
		//	id=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//id=ID
		public Assignment getIdAssignment() { return cIdAssignment; }
		
		//ID
		public RuleCall getIdIDTerminalRuleCall_0() { return cIdIDTerminalRuleCall_0; }
	}
	public class LogicOpBinElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.LogicOpBin");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cANDKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cORKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cXORKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cEqualsSignGreaterThanSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		
		//LogicOpBin:
		//	'AND' | 'OR' | 'XOR' | '=>' | '<=>';
		@Override public ParserRule getRule() { return rule; }
		
		//'AND' | 'OR' | 'XOR' | '=>' | '<=>'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'AND'
		public Keyword getANDKeyword_0() { return cANDKeyword_0; }
		
		//'OR'
		public Keyword getORKeyword_1() { return cORKeyword_1; }
		
		//'XOR'
		public Keyword getXORKeyword_2() { return cXORKeyword_2; }
		
		//'=>'
		public Keyword getEqualsSignGreaterThanSignKeyword_3() { return cEqualsSignGreaterThanSignKeyword_3; }
		
		//'<=>'
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_4() { return cLessThanSignEqualsSignGreaterThanSignKeyword_4; }
	}
	public class LogicOpUnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.LogicOpUn");
		private final Keyword cNOTKeyword = (Keyword)rule.eContents().get(1);
		
		//LogicOpUn:
		//	'NOT';
		@Override public ParserRule getRule() { return rule; }
		
		//'NOT'
		public Keyword getNOTKeyword() { return cNOTKeyword; }
	}
	public class RelationalOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.RelationalOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExclamationMarkEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//RelationalOp:
		//	'>' | '<' | '>=' | '<=' | '=' | '!=';
		@Override public ParserRule getRule() { return rule; }
		
		//'>' | '<' | '>=' | '<=' | '=' | '!='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }
		
		//'<'
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }
		
		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword_2() { return cGreaterThanSignEqualsSignKeyword_2; }
		
		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_3() { return cLessThanSignEqualsSignKeyword_3; }
		
		//'='
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }
		
		//'!='
		public Keyword getExclamationMarkEqualsSignKeyword_5() { return cExclamationMarkEqualsSignKeyword_5; }
	}
	public class GlobalOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.GlobalOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAt_mostKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAll_differentKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//GlobalOp:
		//	'at_most' | 'all_different';
		@Override public ParserRule getRule() { return rule; }
		
		//'at_most' | 'all_different'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'at_most'
		public Keyword getAt_mostKeyword_0() { return cAt_mostKeyword_0; }
		
		//'all_different'
		public Keyword getAll_differentKeyword_1() { return cAll_differentKeyword_1; }
	}
	public class ArithmeticOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.ArithmeticOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAsteriskKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cSolidusKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cModKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cPowKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cDistKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		
		//ArithmeticOp:
		//	'+' | '-' | '*' | '/' | 'mod' | 'pow' | 'dist';
		@Override public ParserRule getRule() { return rule; }
		
		//'+' | '-' | '*' | '/' | 'mod' | 'pow' | 'dist'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'+'
		public Keyword getPlusSignKeyword_0() { return cPlusSignKeyword_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//'*'
		public Keyword getAsteriskKeyword_2() { return cAsteriskKeyword_2; }
		
		//'/'
		public Keyword getSolidusKeyword_3() { return cSolidusKeyword_3; }
		
		//'mod'
		public Keyword getModKeyword_4() { return cModKeyword_4; }
		
		//'pow'
		public Keyword getPowKeyword_5() { return cPowKeyword_5; }
		
		//'dist'
		public Keyword getDistKeyword_6() { return cDistKeyword_6; }
	}
	public class IntegerOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.IntegerOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cAbsKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cMinKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cMaxKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cSqrtKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//IntegerOp:
		//	'abs' | 'min' | 'max' | 'sqrt';
		@Override public ParserRule getRule() { return rule; }
		
		//'abs' | 'min' | 'max' | 'sqrt'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'abs'
		public Keyword getAbsKeyword_0() { return cAbsKeyword_0; }
		
		//'min'
		public Keyword getMinKeyword_1() { return cMinKeyword_1; }
		
		//'max'
		public Keyword getMaxKeyword_2() { return cMaxKeyword_2; }
		
		//'sqrt'
		public Keyword getSqrtKeyword_3() { return cSqrtKeyword_3; }
	}
	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnumerableValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNonEnumerableValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Value:
		//	EnumerableValue | NonEnumerableValue;
		@Override public ParserRule getRule() { return rule; }
		
		//EnumerableValue | NonEnumerableValue
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EnumerableValue
		public RuleCall getEnumerableValueParserRuleCall_0() { return cEnumerableValueParserRuleCall_0; }
		
		//NonEnumerableValue
		public RuleCall getNonEnumerableValueParserRuleCall_1() { return cNonEnumerableValueParserRuleCall_1; }
	}
	public class EnumerableValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.EnumerableValue");
		private final RuleCall cINTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//EnumerableValue:
		//	INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT
		public RuleCall getINTTerminalRuleCall() { return cINTTerminalRuleCall; }
	}
	public class NonEnumerableValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.NonEnumerableValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBoolValParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//NonEnumerableValue:
		//	BoolVal | ID;
		@Override public ParserRule getRule() { return rule; }
		
		//BoolVal | ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BoolVal
		public RuleCall getBoolValParserRuleCall_0() { return cBoolValParserRuleCall_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}
	public class VarTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.VarType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cBoolKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cIntegerKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cSymbolicKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		////
		////Double:
		////	INT'.'INT
		////;
		////
		//VarType:
		//	'bool' | 'integer' | 'symbolic';
		@Override public ParserRule getRule() { return rule; }
		
		//'bool' | 'integer' | 'symbolic'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'bool'
		public Keyword getBoolKeyword_0() { return cBoolKeyword_0; }
		
		//'integer'
		public Keyword getIntegerKeyword_1() { return cIntegerKeyword_1; }
		
		//'symbolic'
		public Keyword getSymbolicKeyword_2() { return cSymbolicKeyword_2; }
	}
	public class ListOfValuesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.ListOfValues");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValuesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValuesValueParserRuleCall_0_0 = (RuleCall)cValuesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cValuesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValuesValueParserRuleCall_1_1_0 = (RuleCall)cValuesAssignment_1_1.eContents().get(0);
		
		////	
		//ListOfValues:
		//	values+=Value (','+ values+=Value)*;
		@Override public ParserRule getRule() { return rule; }
		
		//values+=Value (','+ values+=Value)*
		public Group getGroup() { return cGroup; }
		
		//values+=Value
		public Assignment getValuesAssignment_0() { return cValuesAssignment_0; }
		
		//Value
		public RuleCall getValuesValueParserRuleCall_0_0() { return cValuesValueParserRuleCall_0_0; }
		
		//(','+ values+=Value)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','+
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//values+=Value
		public Assignment getValuesAssignment_1_1() { return cValuesAssignment_1_1; }
		
		//Value
		public RuleCall getValuesValueParserRuleCall_1_1_0() { return cValuesValueParserRuleCall_1_1_0; }
	}
	public class ListOfEnumerablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.ListOfEnumerables");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValuesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValuesEnumerableValueParserRuleCall_0_0 = (RuleCall)cValuesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cValuesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValuesEnumerableValueParserRuleCall_1_1_0 = (RuleCall)cValuesAssignment_1_1.eContents().get(0);
		
		//ListOfEnumerables:
		//	values+=EnumerableValue (','+ values+=EnumerableValue)*;
		@Override public ParserRule getRule() { return rule; }
		
		//values+=EnumerableValue (','+ values+=EnumerableValue)*
		public Group getGroup() { return cGroup; }
		
		//values+=EnumerableValue
		public Assignment getValuesAssignment_0() { return cValuesAssignment_0; }
		
		//EnumerableValue
		public RuleCall getValuesEnumerableValueParserRuleCall_0_0() { return cValuesEnumerableValueParserRuleCall_0_0; }
		
		//(','+ values+=EnumerableValue)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','+
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//values+=EnumerableValue
		public Assignment getValuesAssignment_1_1() { return cValuesAssignment_1_1; }
		
		//EnumerableValue
		public RuleCall getValuesEnumerableValueParserRuleCall_1_1_0() { return cValuesEnumerableValueParserRuleCall_1_1_0; }
	}
	public class ListOfIDsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.CPHLCL.ListOfIDs");
		private final Assignment cIdsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdsIDTerminalRuleCall_0 = (RuleCall)cIdsAssignment.eContents().get(0);
		
		////ListOfNonEnumerables:
		////	values+= NonEnumerableValue (',' + values+= NonEnumerableValue)*
		////	;
		//ListOfIDs:
		//	ids+=ID+;
		@Override public ParserRule getRule() { return rule; }
		
		//ids+=ID+
		public Assignment getIdsAssignment() { return cIdsAssignment; }
		
		//ID
		public RuleCall getIdsIDTerminalRuleCall_0() { return cIdsIDTerminalRuleCall_0; }
	}
	
	
	private final ModelElements pModel;
	private final VarDeclarationElements pVarDeclaration;
	private final DomainDeclarationElements pDomainDeclaration;
	private final IntervalElements pInterval;
	private final EnumerationElements pEnumeration;
	private final ConstraintElements pConstraint;
	private final ExpressionElements pExpression;
	private final BoolTermElements pBoolTerm;
	private final ComplexTermElements pComplexTerm;
	private final LogicElements pLogic;
	private final LogicUnElements pLogicUn;
	private final RelationalElements pRelational;
	private final NumericTermElements pNumericTerm;
	private final ArithmeticElements pArithmetic;
	private final GlobalElements pGlobal;
	private final ControlElements pControl;
	private final StrategyElements pStrategy;
	private final BoolElements pBool;
	private final BoolValElements pBoolVal;
	private final BoolVarElements pBoolVar;
	private final NumberElements pNumber;
	private final IntVarElements pIntVar;
	private final LogicOpBinElements pLogicOpBin;
	private final LogicOpUnElements pLogicOpUn;
	private final RelationalOpElements pRelationalOp;
	private final GlobalOpElements pGlobalOp;
	private final ArithmeticOpElements pArithmeticOp;
	private final IntegerOpElements pIntegerOp;
	private final ValueElements pValue;
	private final EnumerableValueElements pEnumerableValue;
	private final NonEnumerableValueElements pNonEnumerableValue;
	private final VarTypeElements pVarType;
	private final ListOfValuesElements pListOfValues;
	private final ListOfEnumerablesElements pListOfEnumerables;
	private final ListOfIDsElements pListOfIDs;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public CPHLCLGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pVarDeclaration = new VarDeclarationElements();
		this.pDomainDeclaration = new DomainDeclarationElements();
		this.pInterval = new IntervalElements();
		this.pEnumeration = new EnumerationElements();
		this.pConstraint = new ConstraintElements();
		this.pExpression = new ExpressionElements();
		this.pBoolTerm = new BoolTermElements();
		this.pComplexTerm = new ComplexTermElements();
		this.pLogic = new LogicElements();
		this.pLogicUn = new LogicUnElements();
		this.pRelational = new RelationalElements();
		this.pNumericTerm = new NumericTermElements();
		this.pArithmetic = new ArithmeticElements();
		this.pGlobal = new GlobalElements();
		this.pControl = new ControlElements();
		this.pStrategy = new StrategyElements();
		this.pBool = new BoolElements();
		this.pBoolVal = new BoolValElements();
		this.pBoolVar = new BoolVarElements();
		this.pNumber = new NumberElements();
		this.pIntVar = new IntVarElements();
		this.pLogicOpBin = new LogicOpBinElements();
		this.pLogicOpUn = new LogicOpUnElements();
		this.pRelationalOp = new RelationalOpElements();
		this.pGlobalOp = new GlobalOpElements();
		this.pArithmeticOp = new ArithmeticOpElements();
		this.pIntegerOp = new IntegerOpElements();
		this.pValue = new ValueElements();
		this.pEnumerableValue = new EnumerableValueElements();
		this.pNonEnumerableValue = new NonEnumerableValueElements();
		this.pVarType = new VarTypeElements();
		this.pListOfValues = new ListOfValuesElements();
		this.pListOfEnumerables = new ListOfEnumerablesElements();
		this.pListOfIDs = new ListOfIDsElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.CPHLCL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// A CSP is composed by a set of variables with their domains, a set of constraints and a series of search strategies
	//Model:
	//	'model' name=ID 'variables:' vars+=VarDeclaration+ 'constraints:' constraints+=Constraint+
	//	'strategy:' strategy=Strategy;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	////VAriables and domains declarations	
	//VarDeclaration:
	//	type=VarType name=ID 'domain:' domain=DomainDeclaration;
	public VarDeclarationElements getVarDeclarationAccess() {
		return pVarDeclaration;
	}
	
	public ParserRule getVarDeclarationRule() {
		return getVarDeclarationAccess().getRule();
	}
	
	//DomainDeclaration:
	//	Interval | Enumeration //| Mixed //domains
	//;
	public DomainDeclarationElements getDomainDeclarationAccess() {
		return pDomainDeclaration;
	}
	
	public ParserRule getDomainDeclarationRule() {
		return getDomainDeclarationAccess().getRule();
	}
	
	//Interval:
	//	start=EnumerableValue '..' end=EnumerableValue;
	public IntervalElements getIntervalAccess() {
		return pInterval;
	}
	
	public ParserRule getIntervalRule() {
		return getIntervalAccess().getRule();
	}
	
	//Enumeration:
	//	'[' list=ListOfValues ']';
	public EnumerationElements getEnumerationAccess() {
		return pEnumeration;
	}
	
	public ParserRule getEnumerationRule() {
		return getEnumerationAccess().getRule();
	}
	
	///**
	// * Constraints and constraints declarations
	// */ Constraint:
	//	name=ID ':' exp=Expression
	//	//|BoolExpression//|Relational|Global
	//;
	public ConstraintElements getConstraintAccess() {
		return pConstraint;
	}
	
	public ParserRule getConstraintRule() {
		return getConstraintAccess().getRule();
	}
	
	//Expression:
	//	Global | Logic | Relational | Control
	//	//Global|Logic|Relational|IntegerExp|Arithmetic|Control
	//;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	////BooleanExpression:
	////	Logic|Relational
	////;
	//BoolTerm BoolExpression: //'('Logic')'|Bool
	//	'(' ComplexTerm ')' | BoolVar;
	public BoolTermElements getBoolTermAccess() {
		return pBoolTerm;
	}
	
	public ParserRule getBoolTermRule() {
		return getBoolTermAccess().getRule();
	}
	
	//ComplexTerm:
	//	Logic | Relational | LogicUn;
	public ComplexTermElements getComplexTermAccess() {
		return pComplexTerm;
	}
	
	public ParserRule getComplexTermRule() {
		return getComplexTermAccess().getRule();
	}
	
	//Logic:
	//	=> logicLeft=BoolTerm
	//	logicOp=LogicOpBin
	//	=> logicRight=BoolTerm;
	public LogicElements getLogicAccess() {
		return pLogic;
	}
	
	public ParserRule getLogicRule() {
		return getLogicAccess().getRule();
	}
	
	//LogicUn:
	//	logicOp=LogicOpUn '(' exp=BoolTerm ')';
	public LogicUnElements getLogicUnAccess() {
		return pLogicUn;
	}
	
	public ParserRule getLogicUnRule() {
		return getLogicUnAccess().getRule();
	}
	
	//Relational:
	//	=> relationalLeft=NumericTerm
	//	relationalOp=RelationalOp
	//	=> relationalRight=NumericTerm;
	public RelationalElements getRelationalAccess() {
		return pRelational;
	}
	
	public ParserRule getRelationalRule() {
		return getRelationalAccess().getRule();
	}
	
	////
	////NumericExpression:
	////	 IntegerExp |Arithmetic
	////	 
	////;
	//NumericTerm NumExpression: //'(' Arithmetic ')' | Number
	////'('Arithmetic')' |'(' IntegerExp ')' | Number |IntVar
	//	'(' Arithmetic ')' | Number | IntVar;
	public NumericTermElements getNumericTermAccess() {
		return pNumericTerm;
	}
	
	public ParserRule getNumericTermRule() {
		return getNumericTermAccess().getRule();
	}
	
	//Arithmetic:
	//	left=NumericTerm
	//	arithOperator=ArithmeticOp
	//	right=NumericTerm;
	public ArithmeticElements getArithmeticAccess() {
		return pArithmetic;
	}
	
	public ParserRule getArithmeticRule() {
		return getArithmeticAccess().getRule();
	}
	
	////ArithmeticUn:
	////	
	////;
	////IntegerExp:
	////	intOperator=IntegerOp '(' values=ListOfEnumerables ')'  
	////	;
	///**
	// * Global constraints
	// */ Global:
	//	op=GlobalOp '(' vars=ListOfIDs ')';
	public GlobalElements getGlobalAccess() {
		return pGlobal;
	}
	
	public ParserRule getGlobalRule() {
		return getGlobalAccess().getRule();
	}
	
	///*
	// * Control statement if-then-else
	// */ Control:
	//	'if' '(' cond=BoolTerm ')' 'then' trueStatement=Expression 'else' elseStatement=Expression 'end_if';
	public ControlElements getControlAccess() {
		return pControl;
	}
	
	public ParserRule getControlRule() {
		return getControlAccess().getRule();
	}
	
	////Strategies
	//Strategy:
	//	'one' | 'two';
	public StrategyElements getStrategyAccess() {
		return pStrategy;
	}
	
	public ParserRule getStrategyRule() {
		return getStrategyAccess().getRule();
	}
	
	////Terminals and categories
	//Bool:
	//	val=BoolVal;
	public BoolElements getBoolAccess() {
		return pBool;
	}
	
	public ParserRule getBoolRule() {
		return getBoolAccess().getRule();
	}
	
	//BoolVal:
	//	'true' | 'false';
	public BoolValElements getBoolValAccess() {
		return pBoolVal;
	}
	
	public ParserRule getBoolValRule() {
		return getBoolValAccess().getRule();
	}
	
	//BoolVar:
	//	id=ID;
	public BoolVarElements getBoolVarAccess() {
		return pBoolVar;
	}
	
	public ParserRule getBoolVarRule() {
		return getBoolVarAccess().getRule();
	}
	
	//Number:
	//	num=INT;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//IntVar:
	//	id=ID;
	public IntVarElements getIntVarAccess() {
		return pIntVar;
	}
	
	public ParserRule getIntVarRule() {
		return getIntVarAccess().getRule();
	}
	
	//LogicOpBin:
	//	'AND' | 'OR' | 'XOR' | '=>' | '<=>';
	public LogicOpBinElements getLogicOpBinAccess() {
		return pLogicOpBin;
	}
	
	public ParserRule getLogicOpBinRule() {
		return getLogicOpBinAccess().getRule();
	}
	
	//LogicOpUn:
	//	'NOT';
	public LogicOpUnElements getLogicOpUnAccess() {
		return pLogicOpUn;
	}
	
	public ParserRule getLogicOpUnRule() {
		return getLogicOpUnAccess().getRule();
	}
	
	//RelationalOp:
	//	'>' | '<' | '>=' | '<=' | '=' | '!=';
	public RelationalOpElements getRelationalOpAccess() {
		return pRelationalOp;
	}
	
	public ParserRule getRelationalOpRule() {
		return getRelationalOpAccess().getRule();
	}
	
	//GlobalOp:
	//	'at_most' | 'all_different';
	public GlobalOpElements getGlobalOpAccess() {
		return pGlobalOp;
	}
	
	public ParserRule getGlobalOpRule() {
		return getGlobalOpAccess().getRule();
	}
	
	//ArithmeticOp:
	//	'+' | '-' | '*' | '/' | 'mod' | 'pow' | 'dist';
	public ArithmeticOpElements getArithmeticOpAccess() {
		return pArithmeticOp;
	}
	
	public ParserRule getArithmeticOpRule() {
		return getArithmeticOpAccess().getRule();
	}
	
	//IntegerOp:
	//	'abs' | 'min' | 'max' | 'sqrt';
	public IntegerOpElements getIntegerOpAccess() {
		return pIntegerOp;
	}
	
	public ParserRule getIntegerOpRule() {
		return getIntegerOpAccess().getRule();
	}
	
	//Value:
	//	EnumerableValue | NonEnumerableValue;
	public ValueElements getValueAccess() {
		return pValue;
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}
	
	//EnumerableValue:
	//	INT;
	public EnumerableValueElements getEnumerableValueAccess() {
		return pEnumerableValue;
	}
	
	public ParserRule getEnumerableValueRule() {
		return getEnumerableValueAccess().getRule();
	}
	
	//NonEnumerableValue:
	//	BoolVal | ID;
	public NonEnumerableValueElements getNonEnumerableValueAccess() {
		return pNonEnumerableValue;
	}
	
	public ParserRule getNonEnumerableValueRule() {
		return getNonEnumerableValueAccess().getRule();
	}
	
	////
	////Double:
	////	INT'.'INT
	////;
	////
	//VarType:
	//	'bool' | 'integer' | 'symbolic';
	public VarTypeElements getVarTypeAccess() {
		return pVarType;
	}
	
	public ParserRule getVarTypeRule() {
		return getVarTypeAccess().getRule();
	}
	
	////	
	//ListOfValues:
	//	values+=Value (','+ values+=Value)*;
	public ListOfValuesElements getListOfValuesAccess() {
		return pListOfValues;
	}
	
	public ParserRule getListOfValuesRule() {
		return getListOfValuesAccess().getRule();
	}
	
	//ListOfEnumerables:
	//	values+=EnumerableValue (','+ values+=EnumerableValue)*;
	public ListOfEnumerablesElements getListOfEnumerablesAccess() {
		return pListOfEnumerables;
	}
	
	public ParserRule getListOfEnumerablesRule() {
		return getListOfEnumerablesAccess().getRule();
	}
	
	////ListOfNonEnumerables:
	////	values+= NonEnumerableValue (',' + values+= NonEnumerableValue)*
	////	;
	//ListOfIDs:
	//	ids+=ID+;
	public ListOfIDsElements getListOfIDsAccess() {
		return pListOfIDs;
	}
	
	public ParserRule getListOfIDsRule() {
		return getListOfIDsAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

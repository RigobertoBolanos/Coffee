/*
 * generated by Xtext 2.12.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.cPHLCL.Arithmetic;
import org.xtext.cPHLCL.Bool;
import org.xtext.cPHLCL.BoolVar;
import org.xtext.cPHLCL.CPHLCLPackage;
import org.xtext.cPHLCL.Constraint;
import org.xtext.cPHLCL.Control;
import org.xtext.cPHLCL.Enumeration;
import org.xtext.cPHLCL.Global;
import org.xtext.cPHLCL.IntVar;
import org.xtext.cPHLCL.Interval;
import org.xtext.cPHLCL.ListOfEnumerables;
import org.xtext.cPHLCL.ListOfIDs;
import org.xtext.cPHLCL.ListOfValues;
import org.xtext.cPHLCL.Logic;
import org.xtext.cPHLCL.LogicUn;
import org.xtext.cPHLCL.Model;
import org.xtext.cPHLCL.Relational;
import org.xtext.cPHLCL.VarDeclaration;
import org.xtext.services.CPHLCLGrammarAccess;

@SuppressWarnings("all")
public class CPHLCLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CPHLCLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CPHLCLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CPHLCLPackage.ARITHMETIC:
				sequence_Arithmetic(context, (Arithmetic) semanticObject); 
				return; 
			case CPHLCLPackage.BOOL:
				sequence_Bool(context, (Bool) semanticObject); 
				return; 
			case CPHLCLPackage.BOOL_VAR:
				sequence_BoolVar(context, (BoolVar) semanticObject); 
				return; 
			case CPHLCLPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case CPHLCLPackage.CONTROL:
				sequence_Control(context, (Control) semanticObject); 
				return; 
			case CPHLCLPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case CPHLCLPackage.GLOBAL:
				sequence_Global(context, (Global) semanticObject); 
				return; 
			case CPHLCLPackage.INT_VAR:
				sequence_IntVar(context, (IntVar) semanticObject); 
				return; 
			case CPHLCLPackage.INTERVAL:
				sequence_Interval(context, (Interval) semanticObject); 
				return; 
			case CPHLCLPackage.LIST_OF_ENUMERABLES:
				sequence_ListOfEnumerables(context, (ListOfEnumerables) semanticObject); 
				return; 
			case CPHLCLPackage.LIST_OF_IDS:
				sequence_ListOfIDs(context, (ListOfIDs) semanticObject); 
				return; 
			case CPHLCLPackage.LIST_OF_VALUES:
				sequence_ListOfValues(context, (ListOfValues) semanticObject); 
				return; 
			case CPHLCLPackage.LOGIC:
				sequence_Logic(context, (Logic) semanticObject); 
				return; 
			case CPHLCLPackage.LOGIC_UN:
				sequence_LogicUn(context, (LogicUn) semanticObject); 
				return; 
			case CPHLCLPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case CPHLCLPackage.NUMBER:
				sequence_Number(context, (org.xtext.cPHLCL.Number) semanticObject); 
				return; 
			case CPHLCLPackage.RELATIONAL:
				sequence_Relational(context, (Relational) semanticObject); 
				return; 
			case CPHLCLPackage.VAR_DECLARATION:
				sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     NumericTerm returns Arithmetic
	 *     Arithmetic returns Arithmetic
	 *
	 * Constraint:
	 *     (left=NumericTerm arithOperator=ArithmeticOp right=NumericTerm)
	 */
	protected void sequence_Arithmetic(ISerializationContext context, Arithmetic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.ARITHMETIC__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.ARITHMETIC__LEFT));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.ARITHMETIC__ARITH_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.ARITHMETIC__ARITH_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.ARITHMETIC__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.ARITHMETIC__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticAccess().getLeftNumericTermParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArithmeticAccess().getArithOperatorArithmeticOpParserRuleCall_1_0(), semanticObject.getArithOperator());
		feeder.accept(grammarAccess.getArithmeticAccess().getRightNumericTermParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BoolTerm returns BoolVar
	 *     BoolVar returns BoolVar
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_BoolVar(ISerializationContext context, BoolVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.BOOL_VAR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.BOOL_VAR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolVarAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Bool returns Bool
	 *
	 * Constraint:
	 *     val=BoolVal
	 */
	protected void sequence_Bool(ISerializationContext context, Bool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.BOOL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.BOOL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolAccess().getValBoolValParserRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (name=ID exp=Expression)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.CONSTRAINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.CONSTRAINT__NAME));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.CONSTRAINT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.CONSTRAINT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstraintAccess().getExpExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Control
	 *     Control returns Control
	 *
	 * Constraint:
	 *     (cond=BoolTerm trueStatement=Expression elseStatement=Expression)
	 */
	protected void sequence_Control(ISerializationContext context, Control semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.CONTROL__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.CONTROL__COND));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.CONTROL__TRUE_STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.CONTROL__TRUE_STATEMENT));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.CONTROL__ELSE_STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.CONTROL__ELSE_STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getControlAccess().getCondBoolTermParserRuleCall_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getControlAccess().getTrueStatementExpressionParserRuleCall_5_0(), semanticObject.getTrueStatement());
		feeder.accept(grammarAccess.getControlAccess().getElseStatementExpressionParserRuleCall_7_0(), semanticObject.getElseStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DomainDeclaration returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     list=ListOfValues
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.ENUMERATION__LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.ENUMERATION__LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationAccess().getListListOfValuesParserRuleCall_1_0(), semanticObject.getList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Global
	 *     Global returns Global
	 *
	 * Constraint:
	 *     (op=GlobalOp vars=ListOfIDs)
	 */
	protected void sequence_Global(ISerializationContext context, Global semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.GLOBAL__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.GLOBAL__OP));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.GLOBAL__VARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.GLOBAL__VARS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalAccess().getOpGlobalOpParserRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getGlobalAccess().getVarsListOfIDsParserRuleCall_2_0(), semanticObject.getVars());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NumericTerm returns IntVar
	 *     IntVar returns IntVar
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_IntVar(ISerializationContext context, IntVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.INT_VAR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.INT_VAR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntVarAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DomainDeclaration returns Interval
	 *     Interval returns Interval
	 *
	 * Constraint:
	 *     (start=EnumerableValue end=EnumerableValue)
	 */
	protected void sequence_Interval(ISerializationContext context, Interval semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.INTERVAL__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.INTERVAL__START));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.INTERVAL__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.INTERVAL__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalAccess().getStartEnumerableValueParserRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getIntervalAccess().getEndEnumerableValueParserRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListOfEnumerables returns ListOfEnumerables
	 *
	 * Constraint:
	 *     (values+=EnumerableValue values+=EnumerableValue*)
	 */
	protected void sequence_ListOfEnumerables(ISerializationContext context, ListOfEnumerables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListOfIDs returns ListOfIDs
	 *
	 * Constraint:
	 *     ids+=ID+
	 */
	protected void sequence_ListOfIDs(ISerializationContext context, ListOfIDs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListOfValues returns ListOfValues
	 *
	 * Constraint:
	 *     (values+=Value values+=Value*)
	 */
	protected void sequence_ListOfValues(ISerializationContext context, ListOfValues semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BoolTerm returns LogicUn
	 *     ComplexTerm returns LogicUn
	 *     LogicUn returns LogicUn
	 *
	 * Constraint:
	 *     (logicOp=LogicOpUn exp=BoolTerm)
	 */
	protected void sequence_LogicUn(ISerializationContext context, LogicUn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.LOGIC_UN__LOGIC_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.LOGIC_UN__LOGIC_OP));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.LOGIC_UN__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.LOGIC_UN__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicUnAccess().getLogicOpLogicOpUnParserRuleCall_0_0(), semanticObject.getLogicOp());
		feeder.accept(grammarAccess.getLogicUnAccess().getExpBoolTermParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Logic
	 *     BoolTerm returns Logic
	 *     ComplexTerm returns Logic
	 *     Logic returns Logic
	 *
	 * Constraint:
	 *     (logicLeft=BoolTerm logicOp=LogicOpBin logicRight=BoolTerm)
	 */
	protected void sequence_Logic(ISerializationContext context, Logic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.LOGIC__LOGIC_LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.LOGIC__LOGIC_LEFT));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.LOGIC__LOGIC_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.LOGIC__LOGIC_OP));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.LOGIC__LOGIC_RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.LOGIC__LOGIC_RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicAccess().getLogicLeftBoolTermParserRuleCall_0_0(), semanticObject.getLogicLeft());
		feeder.accept(grammarAccess.getLogicAccess().getLogicOpLogicOpBinParserRuleCall_1_0(), semanticObject.getLogicOp());
		feeder.accept(grammarAccess.getLogicAccess().getLogicRightBoolTermParserRuleCall_2_0(), semanticObject.getLogicRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID vars+=VarDeclaration+ constraints+=Constraint+ strategy=Strategy)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumericTerm returns Number
	 *     Number returns Number
	 *
	 * Constraint:
	 *     num=INT
	 */
	protected void sequence_Number(ISerializationContext context, org.xtext.cPHLCL.Number semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.NUMBER__NUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.NUMBER__NUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberAccess().getNumINTTerminalRuleCall_0(), semanticObject.getNum());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Relational
	 *     BoolTerm returns Relational
	 *     ComplexTerm returns Relational
	 *     Relational returns Relational
	 *
	 * Constraint:
	 *     (relationalLeft=NumericTerm relationalOp=RelationalOp relationalRight=NumericTerm)
	 */
	protected void sequence_Relational(ISerializationContext context, Relational semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.RELATIONAL__RELATIONAL_LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.RELATIONAL__RELATIONAL_LEFT));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.RELATIONAL__RELATIONAL_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.RELATIONAL__RELATIONAL_OP));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.RELATIONAL__RELATIONAL_RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.RELATIONAL__RELATIONAL_RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalAccess().getRelationalLeftNumericTermParserRuleCall_0_0(), semanticObject.getRelationalLeft());
		feeder.accept(grammarAccess.getRelationalAccess().getRelationalOpRelationalOpParserRuleCall_1_0(), semanticObject.getRelationalOp());
		feeder.accept(grammarAccess.getRelationalAccess().getRelationalRightNumericTermParserRuleCall_2_0(), semanticObject.getRelationalRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     (type=VarType name=ID domain=DomainDeclaration)
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.VAR_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.VAR_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, CPHLCLPackage.Literals.VAR_DECLARATION__DOMAIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CPHLCLPackage.Literals.VAR_DECLARATION__DOMAIN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclarationAccess().getTypeVarTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVarDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarDeclarationAccess().getDomainDomainDeclarationParserRuleCall_3_0(), semanticObject.getDomain());
		feeder.finish();
	}
	
	
}

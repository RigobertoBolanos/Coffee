/*
 * generated by Xtext 2.12.0
 */
package org.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.pLhlcl.Model
import org.xtext.pLhlcl.VarDeclaration
import org.xtext.pLhlcl.ConsExpression
import org.xtext.pLhlcl.VariantDeclaration
import org.xtext.pLhlcl.VariantsInterval
import org.xtext.pLhlcl.VariantsEnumeration
import org.eclipse.emf.common.util.EList
import org.xtext.pLhlcl.Refinement
import org.xtext.pLhlcl.FodaBin
import org.xtext.pLhlcl.Rule
import org.xtext.pLhlcl.FodaUN
import org.xtext.pLhlcl.IDCons
import org.xtext.pLhlcl.Structural
import java.util.Map
import java.util.HashMap

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PLhlclGenerator extends AbstractGenerator implements CPCode {
	/**
	 * Name of the PL model 
	 */
	private String modelName
	private Map <String, String> parents;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		modelName= modelName(resource.contents.head as Model)
		parents= new HashMap<String,String>();
		fsa.generateFile(modelName+".cp", toCPHLCL(resource.contents.head as Model))

	}
	def modelName(Model model) {
		var name = model.name.toFirstUpper
		return name
	}
	
	def toCPHLCL(Model model) '''
		«HEADER» «modelName»
		«VARIABLES»
		boolean «modelName»
		«FOR v : model.vars»
			«v.declareVariable»
		«ENDFOR»
		«CONSTRAINTS»
		C_«modelName» : «modelName» = 1
		«FOR c : model.constraints»
			«IF c.exp instanceof Structural »
				«var exp= c.exp as Structural»
				«IF exp.min ==0 && exp.max == 0 »
					«getExpression(c.exp)»
				«ENDIF»
			«ELSE»
				«c.name»: «getExpression(c.exp)»
			«ENDIF»	
		«ENDFOR»
«««		«STRATEGY»
	'''
	def declareVariable(VarDeclaration variable) '''
			«variable.type» «variable.name» «declareVariants(variable, variable.variants)»
	'''
	/**
	 * Method for declare variants
	 */
	def declareVariants(VarDeclaration variable, VariantDeclaration variant) '''
		«IF variable.type=="boolean"»
		«ELSE»	
			«IF variant instanceof VariantsInterval»
				domain: «variant.start»..«variant.end»
			«ELSE»
				«IF variant instanceof VariantsEnumeration»
					domain: [«getList(variant.list.values)»]
				«ENDIF»	
			«ENDIF»
		«ENDIF»
	'''
	def  getList(EList l){
		var out= l.get(0) ;
		for(var i=1; i<l.size(); i= i+1 ){
			out= out +", " + l.get(i) ;
		}
		return out;
	}
	
	def getExpression(ConsExpression exp)'''
«««		«IF exp instanceof Refinement»
«««			«declareRefinement(exp, name)»
«««		«ELSE»
		«IF exp instanceof IDCons»
			«exp.name»
		«ELSE»
			«IF exp instanceof FodaBin»
				«declareFodaBin(exp)»
			«ELSE»
				«IF exp instanceof Rule»
					«declareRule(exp)»
				«ELSE»
					«IF exp instanceof Structural»
						«declareStructural(exp)»
					«ELSE»
						«IF exp instanceof FodaUN»
							«declareFodaUnary(exp)»
						«ENDIF»
					«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
	'''
	def declareRule(Rule rule)'''
		«val left= getExpression(rule.condition as ConsExpression)»
		«val right= getExpression (rule.consequence as ConsExpression)»
		(«left») => («right»)
	'''
	def declareFodaBin(FodaBin exp) '''
		«val left= exp.var1.name»
		«val right= exp.var2.name»
		«IF exp.op=="requires"»
			«left» => «right»
		«ELSE»
			«IF exp.op=="excludes"»
				«left» + «right»<= 1
			«ELSE»
				«IF exp.op=="mandatory"»
					«left» = «right»
				«ELSE»
					«left» >= «right»
				«ENDIF»
			«ENDIF»
		«ENDIF»
	'''
	def declareStructural(Structural exp)'''
		«IF exp.min ==0 && exp.max == 0»
			«{declareParents(exp); ""}»
		«ELSE»
			«var String idsSum=""»
			«FOR child : exp.group.ids»
				(«child.name» => «exp.parent») AND
				«{idsSum+= child.name +"+"; ""}»
				«{parents.put(child.name, exp.parent)+"+"; ""}»
			«ENDFOR»
			(«exp.parent»>= 1) => («idsSum.substring(0, idsSum.length() - 1)» >= «exp.min») AND
			(«exp.parent»>= 1) => («idsSum.substring(0, idsSum.length() - 1)» <= «exp.max») 
		«ENDIF»
	'''
	def declareParents(Structural exp){
		for (element : exp.group.ids) {
			parents.put(element.name, exp.parent)
		}
	}
	def declareFodaUnary(FodaUN exp) '''
		«IF exp.op=="optional"»
			«parents.get(exp.var1.name)» >= «exp.var1.name»
		«ELSE»
			«IF exp.op=="mandatory"»
				«parents.get(exp.var1.name)» = «exp.var1.name»
			«ELSE»
			«ENDIF»
		«ENDIF»
	'''
}

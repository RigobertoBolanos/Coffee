/**
 * generated by Xtext 2.12.0
 */
package org.xtext.generator;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.xtext.generator.CPCode;
import org.xtext.pLhlcl.ConsExpression;
import org.xtext.pLhlcl.Constraint;
import org.xtext.pLhlcl.Expression;
import org.xtext.pLhlcl.FodaBin;
import org.xtext.pLhlcl.FodaUN;
import org.xtext.pLhlcl.IDCons;
import org.xtext.pLhlcl.Model;
import org.xtext.pLhlcl.Rule;
import org.xtext.pLhlcl.Structural;
import org.xtext.pLhlcl.VarDeclaration;
import org.xtext.pLhlcl.VariantDeclaration;
import org.xtext.pLhlcl.VariantsEnumeration;
import org.xtext.pLhlcl.VariantsInterval;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class PLhlclGenerator extends AbstractGenerator implements CPCode {
  /**
   * Name of the PL model
   */
  private String modelName;
  
  private Map<String, String> parents;
  
  private ArrayList<String> clonConstraints;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    this.modelName = this.modelName(((Model) _head));
    HashMap<String, String> _hashMap = new HashMap<String, String>();
    this.parents = _hashMap;
    ArrayList<String> _arrayList = new ArrayList<String>();
    this.clonConstraints = _arrayList;
    EObject _head_1 = IterableExtensions.<EObject>head(resource.getContents());
    fsa.generateFile((this.modelName + ".cp"), this.toCPHLCL(((Model) _head_1)));
  }
  
  public String modelName(final Model model) {
    String name = StringExtensions.toFirstUpper(model.getName());
    return name;
  }
  
  public CharSequence toCPHLCL(final Model model) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append(CPCode.HEADER);
    _builder.append(" ");
    _builder.append(this.modelName);
    _builder.newLineIfNotEmpty();
    _builder.append(CPCode.VARIABLES);
    _builder.newLineIfNotEmpty();
    _builder.append("boolean ");
    _builder.append(this.modelName);
    _builder.newLineIfNotEmpty();
    {
      EList<VarDeclaration> _vars = model.getVars();
      for(final VarDeclaration v : _vars) {
        CharSequence _declareVariable = this.declareVariable(v);
        _builder.append(_declareVariable);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append(CPCode.CONSTRAINTS);
    _builder.newLineIfNotEmpty();
    _builder.append("C_");
    _builder.append(this.modelName);
    _builder.append(" : ");
    _builder.append(this.modelName);
    _builder.append(" = 1");
    _builder.newLineIfNotEmpty();
    CharSequence _declareClonConstraints = this.declareClonConstraints();
    _builder.append(_declareClonConstraints);
    _builder.newLineIfNotEmpty();
    {
      EList<Constraint> _constraints = model.getConstraints();
      for(final Constraint c : _constraints) {
        {
          ConsExpression _exp = c.getExp();
          if ((_exp instanceof Structural)) {
            ConsExpression _exp_1 = c.getExp();
            Structural exp = ((Structural) _exp_1);
            _builder.newLineIfNotEmpty();
            {
              if (((exp.getMin() == null) && (exp.getMax() == null))) {
                this.declareParents(exp);
                _builder.newLineIfNotEmpty();
              } else {
                String _name = c.getName();
                _builder.append(_name);
                _builder.append(": ");
                CharSequence _expression = this.getExpression(c.getExp());
                _builder.append(_expression);
                _builder.newLineIfNotEmpty();
              }
            }
          } else {
            String _name_1 = c.getName();
            _builder.append(_name_1);
            _builder.append(": ");
            CharSequence _expression_1 = this.getExpression(c.getExp());
            _builder.append(_expression_1);
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence declareVariable(final VarDeclaration variable) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _declareSingleVar = this.declareSingleVar(variable);
    _builder.append(_declareSingleVar);
    _builder.newLineIfNotEmpty();
    {
      boolean _not = (!((variable.getMin() == null) && (variable.getMax() == null)));
      if (_not) {
        String _declareInstances = this.declareInstances(variable);
        _builder.append(_declareInstances);
        _builder.append("\t");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  /**
   * Method to declare a variable without clones
   */
  public CharSequence declareSingleVar(final VarDeclaration variable) {
    StringConcatenation _builder = new StringConcatenation();
    String _type = variable.getType();
    _builder.append(_type);
    _builder.append(" ");
    String _name = variable.getName();
    _builder.append(_name);
    _builder.append(" ");
    CharSequence _declareVariants = this.declareVariants(variable, variable.getVariants());
    _builder.append(_declareVariants);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  /**
   * Method to declare a variable's with clones
   */
  public String declareInstances(final VarDeclaration variable) {
    String _xblockexpression = null;
    {
      String declaration = "";
      int _value = variable.getMin().getValue();
      String _plus = ("(" + Integer.valueOf(_value));
      String left = (_plus + "<=");
      int _value_1 = variable.getMax().getValue();
      String _plus_1 = ("(" + Integer.valueOf(_value_1));
      String right = (_plus_1 + ">=");
      String sum = "";
      for (int i = 1; (i <= variable.getMax().getValue()); i = (i + 1)) {
        {
          String _declaration = declaration;
          String _name = variable.getName();
          String _plus_2 = ("boolean " + _name);
          String _plus_3 = (_plus_2 + Integer.valueOf(i));
          String _plus_4 = (_plus_3 + "\n");
          declaration = (_declaration + _plus_4);
          String _sum = sum;
          String _name_1 = variable.getName();
          String _plus_5 = (_name_1 + Integer.valueOf(i));
          String _plus_6 = (_plus_5 + " +");
          sum = (_sum + _plus_6);
        }
      }
      String _left = left;
      int _length = sum.length();
      int _minus = (_length - 1);
      String _substring = sum.substring(0, _minus);
      String _plus_2 = (_substring + ") ");
      left = (_left + _plus_2);
      String _right = right;
      int _length_1 = sum.length();
      int _minus_1 = (_length_1 - 1);
      String _substring_1 = sum.substring(0, _minus_1);
      String _plus_3 = (_substring_1 + ") ");
      right = (_right + _plus_3);
      String _name = variable.getName();
      String _plus_4 = (_name + " => (");
      String _plus_5 = (_plus_4 + left);
      String _plus_6 = (_plus_5 + "AND");
      String _plus_7 = (_plus_6 + right);
      String constraint = (_plus_7 + ")");
      this.clonConstraints.add(constraint);
      _xblockexpression = declaration;
    }
    return _xblockexpression;
  }
  
  /**
   * Declare clon constraints
   */
  public CharSequence declareClonConstraints() {
    StringConcatenation _builder = new StringConcatenation();
    int id = 1;
    _builder.newLineIfNotEmpty();
    {
      for(final String constraint : this.clonConstraints) {
        _builder.append("clon");
        _builder.append(id);
        _builder.append(": ");
        String _string = constraint.toString();
        _builder.append(_string);
        _builder.newLineIfNotEmpty();
        String _xblockexpression = null;
        {
          int _plusPlus = id++;
          /* (Integer.valueOf(_plusPlus) + "+"); */
          _xblockexpression = "";
        }
        _builder.append(_xblockexpression);
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  /**
   * Method for declare variants
   */
  public CharSequence declareVariants(final VarDeclaration variable, final VariantDeclaration variant) {
    StringConcatenation _builder = new StringConcatenation();
    {
      String _type = variable.getType();
      boolean _equals = Objects.equal(_type, "boolean");
      if (_equals) {
      } else {
        {
          if ((variant instanceof VariantsInterval)) {
            _builder.append("domain: ");
            org.xtext.pLhlcl.Number _start = ((VariantsInterval)variant).getStart();
            _builder.append(_start);
            _builder.append("..");
            org.xtext.pLhlcl.Number _end = ((VariantsInterval)variant).getEnd();
            _builder.append(_end);
            _builder.newLineIfNotEmpty();
          } else {
            {
              if ((variant instanceof VariantsEnumeration)) {
                _builder.append("domain: [");
                Object _list = this.getList(((VariantsEnumeration)variant).getList().getValues());
                _builder.append(_list);
                _builder.append("]");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public Object getList(final EList l) {
    Object out = l.get(0);
    for (int i = 1; (i < l.size()); i = (i + 1)) {
      String _plus = (out + ", ");
      Object _get = l.get(i);
      String _plus_1 = (_plus + _get);
      out = _plus_1;
    }
    return out;
  }
  
  public CharSequence getExpression(final ConsExpression exp) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if ((exp instanceof IDCons)) {
        String _name = ((IDCons)exp).getName();
        _builder.append(_name);
        _builder.newLineIfNotEmpty();
      } else {
        {
          if ((exp instanceof FodaBin)) {
            CharSequence _declareFodaBin = this.declareFodaBin(((FodaBin)exp));
            _builder.append(_declareFodaBin);
            _builder.newLineIfNotEmpty();
          } else {
            {
              if ((exp instanceof Rule)) {
                CharSequence _declareRule = this.declareRule(((Rule)exp));
                _builder.append(_declareRule);
                _builder.newLineIfNotEmpty();
              } else {
                {
                  if ((exp instanceof Structural)) {
                    CharSequence _declareStructural = this.declareStructural(((Structural)exp));
                    _builder.append(_declareStructural);
                    _builder.newLineIfNotEmpty();
                  } else {
                    {
                      if ((exp instanceof FodaUN)) {
                        CharSequence _declareFodaUnary = this.declareFodaUnary(((FodaUN)exp));
                        _builder.append(_declareFodaUnary);
                        _builder.newLineIfNotEmpty();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence declareRule(final Rule rule) {
    StringConcatenation _builder = new StringConcatenation();
    Expression _condition = rule.getCondition();
    final Object left = this.getExpression(((ConsExpression) _condition));
    _builder.newLineIfNotEmpty();
    Expression _consequence = rule.getConsequence();
    final Object right = this.getExpression(((ConsExpression) _consequence));
    _builder.newLineIfNotEmpty();
    _builder.append("(");
    _builder.append(left);
    _builder.append(") => (");
    _builder.append(right);
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence declareFodaBin(final FodaBin exp) {
    StringConcatenation _builder = new StringConcatenation();
    final String left = exp.getVar1().getName();
    _builder.newLineIfNotEmpty();
    final String right = exp.getVar2().getName();
    _builder.newLineIfNotEmpty();
    {
      String _op = exp.getOp();
      boolean _equals = Objects.equal(_op, "requires");
      if (_equals) {
        {
          if (((exp.getVar1().getMin() == null) && (exp.getVar1().getMax() == null))) {
            _builder.append(left);
            _builder.append("  => ");
            _builder.append(right);
            _builder.append(" ");
            _builder.newLineIfNotEmpty();
          } else {
            String declaration = ((((("(" + left) + "1") + " => ") + right) + ")");
            _builder.newLineIfNotEmpty();
            for (int i = 2; (i <= exp.getVar1().getMax().getValue()); i = (i + 1)) {
              String _declaration = declaration;
              declaration = (_declaration + (((((" AND (" + left) + Integer.valueOf(i)) + " => ") + right) + ")"));
            }
            _builder.newLineIfNotEmpty();
            _builder.append(declaration);
            _builder.newLineIfNotEmpty();
          }
        }
      } else {
        {
          String _op_1 = exp.getOp();
          boolean _equals_1 = Objects.equal(_op_1, "excludes");
          if (_equals_1) {
            {
              if (((exp.getVar1().getMin() == null) && (exp.getVar1().getMax() == null))) {
                _builder.append(left);
                _builder.append(" + ");
                _builder.append(right);
                _builder.append("<= 1 ");
                _builder.newLineIfNotEmpty();
              } else {
                String declaration_1 = ((((("(" + left) + "1") + " + ") + right) + "<= 1)");
                _builder.newLineIfNotEmpty();
                for (int i = 2; (i <= exp.getVar1().getMax().getValue()); i = (i + 1)) {
                  String _declaration = declaration_1;
                  declaration_1 = (_declaration + (((((" AND (" + left) + Integer.valueOf(i)) + " + ") + right) + "<= 1)"));
                }
                _builder.newLineIfNotEmpty();
                _builder.append(declaration_1);
                _builder.newLineIfNotEmpty();
              }
            }
          } else {
            {
              String _op_2 = exp.getOp();
              boolean _equals_2 = Objects.equal(_op_2, "mandatory");
              if (_equals_2) {
                _builder.append(left);
                _builder.append(" = ");
                _builder.append(right);
                _builder.newLineIfNotEmpty();
              } else {
                _builder.append(left);
                _builder.append(" >= ");
                _builder.append(right);
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence declareStructural(final Structural exp) {
    StringConcatenation _builder = new StringConcatenation();
    {
      if ((Objects.equal(exp.getMin(), Integer.valueOf(0)) && Objects.equal(exp.getMax(), Integer.valueOf(0)))) {
        String _xblockexpression = null;
        {
          this.declareParents(exp);
          _xblockexpression = "";
        }
        _builder.append(_xblockexpression);
        _builder.newLineIfNotEmpty();
      } else {
        String idsSum = "";
        _builder.newLineIfNotEmpty();
        {
          EList<VarDeclaration> _ids = exp.getGroup().getIds();
          for(final VarDeclaration child : _ids) {
            _builder.append("(");
            String _name = child.getName();
            _builder.append(_name);
            _builder.append(" => ");
            String _parent = exp.getParent();
            _builder.append(_parent);
            _builder.append(") AND");
            _builder.newLineIfNotEmpty();
            String _xblockexpression_1 = null;
            {
              String _idsSum = idsSum;
              String _name_1 = child.getName();
              String _plus = (_name_1 + "+");
              idsSum = (_idsSum + _plus);
              _xblockexpression_1 = "";
            }
            _builder.append(_xblockexpression_1);
            _builder.newLineIfNotEmpty();
            String _xblockexpression_2 = null;
            {
              String _put = this.parents.put(child.getName(), exp.getParent());
              /* (_put + "+"); */
              _xblockexpression_2 = "";
            }
            _builder.append(_xblockexpression_2);
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("(");
        String _parent_1 = exp.getParent();
        _builder.append(_parent_1);
        _builder.append(">= 1) => (");
        int _length = idsSum.length();
        int _minus = (_length - 1);
        String _substring = idsSum.substring(0, _minus);
        _builder.append(_substring);
        _builder.append(" >= ");
        int _value = exp.getMin().getValue();
        _builder.append(_value);
        _builder.append(") AND");
        _builder.newLineIfNotEmpty();
        _builder.append("(");
        String _parent_2 = exp.getParent();
        _builder.append(_parent_2);
        _builder.append(">= 1) => (");
        int _length_1 = idsSum.length();
        int _minus_1 = (_length_1 - 1);
        String _substring_1 = idsSum.substring(0, _minus_1);
        _builder.append(_substring_1);
        _builder.append(" <= ");
        int _value_1 = exp.getMax().getValue();
        _builder.append(_value_1);
        _builder.append(") ");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public void declareParents(final Structural exp) {
    EList<VarDeclaration> _ids = exp.getGroup().getIds();
    for (final VarDeclaration element : _ids) {
      this.parents.put(element.getName(), exp.getParent());
    }
  }
  
  public CharSequence declareFodaUnary(final FodaUN exp) {
    StringConcatenation _builder = new StringConcatenation();
    {
      String _op = exp.getOp();
      boolean _equals = Objects.equal(_op, "optional");
      if (_equals) {
        String _get = this.parents.get(exp.getVar1().getName());
        _builder.append(_get);
        _builder.append(" >= ");
        String _name = exp.getVar1().getName();
        _builder.append(_name);
        _builder.newLineIfNotEmpty();
      } else {
        {
          String _op_1 = exp.getOp();
          boolean _equals_1 = Objects.equal(_op_1, "mandatory");
          if (_equals_1) {
            String _get_1 = this.parents.get(exp.getVar1().getName());
            _builder.append(_get_1);
            _builder.append(" = ");
            String _name_1 = exp.getVar1().getName();
            _builder.append(_name_1);
            _builder.newLineIfNotEmpty();
          } else {
          }
        }
      }
    }
    return _builder;
  }
}
